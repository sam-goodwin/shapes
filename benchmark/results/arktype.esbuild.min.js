var it=class extends Error{},m=e=>{throw new it(e)},at=class extends Error{},u=e=>{throw new at(e)};var U=(e,t)=>y(e)===t,y=e=>{let t=typeof e;return t==="object"?e===null?"null":"object":t==="function"?"object":t},ct={bigint:"a bigint",boolean:"boolean",null:"null",number:"a number",object:"an object",string:"a string",symbol:"a symbol",undefined:"undefined"};var $=(e,t)=>e in t,Vt=e=>Object.entries(e),f=e=>Object.keys(e),Z=e=>{let t=[];for(;e!==Object.prototype&&e!==null&&e!==void 0;){for(let r of Object.getOwnPropertyNames(e))t.includes(r)||t.push(r);for(let r of Object.getOwnPropertySymbols(e))t.includes(r)||t.push(r);e=Object.getPrototypeOf(e)}return t},ee=(e,t)=>{let r=e?.[t];return r!=null};var Ht=e=>Object.keys(e).length,le=e=>U(e,"object")?Object.keys(e).length!==0:!1,As=Symbol("id");var B=e=>Array.isArray(e)?e:[e];var w=class e extends Array{static fromString(t,r="/"){return t===r?new e:new e(...t.split(r))}toString(t="/"){return this.length?this.join(t):t}},Jt=(e,t)=>{let r=e;for(let o of t){if(typeof r!="object"||r===null)return;r=r[o]}return r};var pt=/^(?!^-0$)-?(?:0|[1-9]\d*)(?:\.\d*[1-9])?$/,Ro=e=>pt.test(e),Io=/^-?\d*\.?\d*$/,Do=e=>e.length!==0&&Io.test(e),Re=/^(?:0|(?:-?[1-9]\d*))$/,ue=e=>Re.test(e),me=/^(?:0|(?:[1-9]\d*))$/,Qt=/^-?\d+$/,ko=e=>Qt.test(e),Xt={number:"a number",bigint:"a bigint",integer:"an integer"},Yt=(e,t)=>`'${e}' was parsed as ${Xt[t]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`,Bo=(e,t)=>t==="number"?Ro(e):ue(e),Co=(e,t)=>t==="number"?Number(e):Number.parseInt(e),To=(e,t)=>t==="number"?Do(e):ko(e),fe=(e,t)=>er(e,"number",t),Ie=(e,t)=>er(e,"integer",t),er=(e,t,r)=>{let o=Co(e,t);if(!Number.isNaN(o)){if(Bo(e,t))return o;if(To(e,t))return u(Yt(e,t))}return r?u(r===!0?`Failed to parse ${Xt[t]} from '${e}'`:r):void 0},lt=e=>{if(e[e.length-1]!=="n")return;let t=e.slice(0,-1),r;try{r=BigInt(t)}catch{return}if(Re.test(t))return r;if(Qt.test(t))return u(Yt(e,"bigint"))};var h=(e,t)=>{switch(y(e)){case"object":return JSON.stringify(ut(e,De,[]),null,t);case"symbol":return De.onSymbol(e);default:return mt(e)}},De={onCycle:()=>"(cycle)",onSymbol:e=>`(symbol${e.description&&` ${e.description}`})`,onFunction:e=>`(function${e.name&&` ${e.name}`})`},ut=(e,t,r)=>{switch(y(e)){case"object":if(typeof e=="function")return De.onFunction(e);if(r.includes(e))return"(cycle)";let o=[...r,e];if(Array.isArray(e))return e.map(s=>ut(s,t,o));let n={};for(let s in e)n[s]=ut(e[s],t,o);return n;case"symbol":return De.onSymbol(e);case"bigint":return`${e}n`;case"undefined":return"undefined";default:return e}},mt=e=>typeof e=="string"?`'${e}'`:typeof e=="bigint"?`${e}n`:`${e}`;function Mo(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}function No(e,t){return t.get?t.get.call(e):t.value}function Eo(e,t,r){if(t.set)t.set.call(e,r);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=r}}function rr(e,t,r){if(!t.has(e))throw new TypeError("attempted to "+r+" private field on non-instance");return t.get(e)}function tr(e,t){var r=rr(e,t,"get");return No(e,r)}function Ao(e,t,r){Mo(e,t),t.set(e,r)}function Ko(e,t,r){var o=rr(e,t,"set");return Eo(e,o,r),r}function te(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var P=e=>(t,r,o)=>t===void 0?r===void 0?m(Ce):r:r===void 0?t:e(t,r,o),Ce="Unexpected operation two undefined operands",ft={domain:({l:e,r:t})=>`${e.join(", ")} and ${t.join(", ")}`,range:({l:e,r:t})=>`${Be(e)} and ${Be(t)}`,class:({l:e,r:t})=>`classes ${typeof e=="string"?e:e.name} and ${typeof t=="string"?t:t.name}`,tupleLength:({l:e,r:t})=>`tuples of length ${e} and ${t}`,value:({l:e,r:t})=>`literal values ${h(e)} and ${h(t)}`,leftAssignability:({l:e,r:t})=>`literal value ${h(e.value)} and ${h(t)}`,rightAssignability:({l:e,r:t})=>`literal value ${h(t.value)} and ${h(e)}`,union:({l:e,r:t})=>`branches ${h(e)} and branches ${h(t)}`},Be=e=>"limit"in e?`the range of exactly ${e.limit}`:e.min?e.max?`the range bounded by ${e.min.comparator}${e.min.limit} and ${e.max.comparator}${e.max.limit}`:`${e.min.comparator}${e.min.limit}`:e.max?`${e.max.comparator}${e.max.limit}`:"the unbounded range",ke=new WeakMap,z=class{get disjoints(){return tr(this,ke)}addDisjoint(t,r,o){return tr(this,ke)[`${this.path}`]={kind:t,l:r,r:o,lOptional:this.lOptional,rOptional:this.rOptional},Te}constructor(t,r){te(this,"type",void 0),te(this,"lastOperator",void 0),te(this,"path",void 0),te(this,"lOptional",void 0),te(this,"rOptional",void 0),te(this,"domain",void 0),Ao(this,ke,{writable:!0,value:void 0}),this.type=t,this.lastOperator=r,this.path=new w,this.lOptional=!1,this.rOptional=!1,Ko(this,ke,{})}},Te=Symbol("empty"),or=()=>Te,D=e=>e===Te,nr=Symbol("equal"),x=()=>nr,j=e=>e===nr,re=(e,t)=>(r,o,n)=>{let s={},i=f({...r,...o}),a=!0,c=!0;for(let p of i){let l=typeof e=="function"?e(p,r[p],o[p],n):e[p](r[p],o[p],n);if(j(l))r[p]!==void 0&&(s[p]=r[p]);else if(D(l))if(t.onEmpty==="omit")a=!1,c=!1;else return Te;else l!==void 0&&(s[p]=l),a&&(a=l===r[p]),c&&(c=l===o[p])}return a?c?x():r:c?o:s};var sr=e=>{let t=f(e);if(t.length===1){let o=t[0];return`${o==="/"?"":`At ${o}: `}Intersection of ${ft[e[o].kind](e[o])} results in an unsatisfiable type`}let r=`
        "Intersection results in unsatisfiable types at the following paths:
`;for(let o in e)r+=`  ${o}: ${ft[e[o].kind](e[o])}
`;return r},Me=(e,t,r)=>`${e.length?`At ${e}: `:""}${t} ${r?`${r} `:""}results in an unsatisfiable type`;var de={Array,Date,Error,Function,Map,RegExp,Set,Object,String,Number,Boolean,WeakMap,WeakSet,Promise},oe=(e,t)=>{if(y(e)!=="object")return;let r=t??de,o=Object.getPrototypeOf(e);for(;o?.constructor&&(!r[o.constructor.name]||!(e instanceof r[o.constructor.name]));)o=Object.getPrototypeOf(o);return o?.constructor?.name};var q=e=>Array.isArray(e),dt={Object:"an object",Array:"an array",Function:"a function",Date:"a Date",RegExp:"a RegExp",Error:"an Error",Map:"a Map",Set:"a Set",String:"a String object",Number:"a Number object",Boolean:"a Boolean object",Promise:"a Promise",WeakMap:"a WeakMap",WeakSet:"a WeakSet"},Ne=e=>{let t=Object(e).name;return t&&$(t,de)&&de[t]===e?t:void 0};var ir=P((e,t,r)=>e===t?x():e instanceof t?e:t instanceof e?t:r.addDisjoint("class",e,t)),ar=(e,t)=>typeof e=="string"?oe(t.data)===e||!t.problems.add("class",e):t.data instanceof e||!t.problems.add("class",e);var Ee=(e,t)=>{if(Array.isArray(e)){if(Array.isArray(t)){let r=So(e,t);return r.length===e.length?r.length===t.length?x():e:r.length===t.length?t:r}return e.includes(t)?e:[...e,t]}return Array.isArray(t)?t.includes(e)?t:[...t,e]:e===t?x():[e,t]},So=(e,t)=>{let r=[...e];for(let o of t)e.includes(o)||r.push(o);return r};var cr=P((e,t)=>e===t?x():Math.abs(e*t/Fo(e,t))),Fo=(e,t)=>{let r,o=e,n=t;for(;n!==0;)r=n,n=o%n,o=r;return o},pr=(e,t)=>t.data%e===0||!t.problems.add("divisor",e);var he=e=>e[0]==="?",Ae=e=>e[0]==="!",T={index:"[index]"},_=e=>he(e)||Ae(e)?e[1]:e,Uo=e=>{if(typeof e.length=="object"&&Ae(e.length)&&typeof e.length[1]!="string"&&Se(e.length[1],"number"))return e.length[1].number.value},lr=P((e,t,r)=>{let o=zo(e,t,r);if(typeof o=="symbol")return o;let n=Uo(o);if(n===void 0||!(T.index in o))return o;let{[T.index]:s,...i}=o,a=_(s);for(let c=0;c<n;c++){if(!i[c]){i[c]=a;continue}let p=_(i[c]);r.path.push(`${c}`);let l=Ke(p,a,r);if(r.path.pop(),D(l))return l;!j(l)&&l!==p&&(i[c]=l)}return i}),zo=re((e,t,r,o)=>{if(t===void 0)return r===void 0?x():r;if(r===void 0)return t;o.path.push(e);let n=o.lOptional,s=o.rOptional;(c=o).lOptional||(c.lOptional=he(t)),(p=o).rOptional||(p.rOptional=he(r));let i=Ke(_(t),_(r),o),a=o.lOptional&&o.rOptional;if(o.rOptional=s,o.lOptional=n,o.path.pop(),D(i)&&a){var c,p;return{}}return i},{onEmpty:"bubble"}),ur=(e,t,r)=>{let o=r.type.config?.keys??r.type.scope.config.keys;return o==="loose"?qo(e,t,r):_o(o,e,t,r)},qo=(e,t,r)=>{for(let o in t){let n=t[o];r.path.push(o),o===T.index?e.push(["indexProp",C(_(n),r)]):he(n)?e.push(["optionalProp",[o,C(n[1],r)]]):Ae(n)?e.push(["prerequisiteProp",[o,C(n[1],r)]]):e.push(["requiredProp",[o,C(n,r)]]),r.path.pop()}},_o=(e,t,r,o)=>{let n={required:{},optional:{}};for(let s in r){let i=r[s];o.path.push(s),s===T.index?n.index=C(_(i),o):he(i)?n.optional[s]=C(i[1],o):Ae(i)?t.push(["prerequisiteProp",[s,C(i[1],o)]]):n.required[s]=C(i,o),o.path.pop()}t.push([`${e}Props`,n])};function Wo(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var ht=e=>typeof e=="string"||Array.isArray(e)?e.length:typeof e=="number"?e:0,Lo=e=>typeof e=="string"?"characters":Array.isArray(e)?"items long":"",Fe=class{toString(){return h(this.value)}get domain(){return y(this.value)}get size(){return ht(this.value)}get units(){return Lo(this.value)}get className(){return Object(this.value).constructor.name}constructor(t){Wo(this,"value",void 0),this.value=t}};var Ue={">":!0,">=":!0},yt={"<":!0,"<=":!0},ye=e=>"comparator"in e,fr=P((e,t,r)=>{if(ye(e))return ye(t)?e.limit===t.limit?x():r.addDisjoint("range",e,t):mr(t,e.limit)?e:r.addDisjoint("range",e,t);if(ye(t))return mr(e,t.limit)?t:r.addDisjoint("range",e,t);let o=ne("min",e.min,t.min),n=ne("max",e.max,t.max);return o==="l"?n==="r"?ne("min",e.min,t.max)==="l"?r.addDisjoint("range",e,t):{min:e.min,max:t.max}:e:o==="r"?n==="l"?ne("max",e.max,t.min)==="l"?r.addDisjoint("range",e,t):{min:t.min,max:e.max}:t:n==="l"?e:n==="r"?t:x()}),mr=(e,t)=>ye(e)?t===e.limit:Go(e.min,t)&&Zo(e.max,t),Go=(e,t)=>!e||t>e.limit||t===e.limit&&!ge(e.comparator),Zo=(e,t)=>!e||t<e.limit||t===e.limit&&!ge(e.comparator),dr=(e,t,r)=>{let o=r.lastDomain==="string"?"characters":r.lastDomain==="object"?"items long":void 0;if(ye(t))return e.push(["bound",o?{...t,units:o}:t]);t.min&&e.push(["bound",o?{...t.min,units:o}:t.min]),t.max&&e.push(["bound",o?{...t.max,units:o}:t.max])},hr=(e,t)=>Vo[e.comparator](ht(t.data),e.limit)||!t.problems.add("bound",e),Vo={"<":(e,t)=>e<t,">":(e,t)=>e>t,"<=":(e,t)=>e<=t,">=":(e,t)=>e>=t,"==":(e,t)=>e===t},ne=(e,t,r)=>t?r?t.limit===r.limit?ge(t.comparator)?ge(r.comparator)?"=":"l":ge(r.comparator)?"r":"=":e==="min"?t.limit>r.limit?"l":"r":t.limit<r.limit?"l":"r":"l":r?"r":"=",ge=e=>e.length===1;var gt={},bt=e=>(gt[e]||(gt[e]=new RegExp(e)),gt[e]),yr=(e,t)=>bt(e).test(t.data)||!t.problems.add("regex",`/${e}/`),gr=P(Ee);var xr=(e,t,r)=>"value"in e?"value"in t?e.value===t.value?x():r.addDisjoint("value",e.value,t.value):br(e.value,t,r)?e:r.addDisjoint("leftAssignability",e,t):"value"in t?br(t.value,e,r)?t:r.addDisjoint("rightAssignability",e,t):Jo(e,t,r),Ho=P(Ee),Jo=re({divisor:cr,regex:gr,props:lr,class:ir,range:fr,narrow:Ho},{onEmpty:"bubble"}),xt=(e,t)=>{let r=[],o;for(o in e)Qo[o](r,e[o],t);return r.sort((n,s)=>be[n[0]]-be[s[0]])},Qo={regex:(e,t)=>{for(let r of B(t))e.push(["regex",r])},divisor:(e,t)=>{e.push(["divisor",t])},range:dr,class:(e,t)=>{e.push(["class",t])},props:ur,narrow:(e,t)=>{for(let r of B(t))e.push(["narrow",r])},value:(e,t)=>{e.push(["value",t])}},be={config:-1,domain:0,value:0,domains:0,branches:0,switch:0,alias:0,class:0,regex:1,divisor:1,bound:1,prerequisiteProp:2,distilledProps:3,strictProps:3,requiredProp:3,optionalProp:3,indexProp:3,narrow:4,morph:5},br=(e,t,r)=>!r.type.scope.type(["node",{[r.domain]:t}])(e).problems;var vt=e=>e?.lBranches!==void 0,wr=(e,t,r)=>{let o={lBranches:e,rBranches:t,lExtendsR:[],rExtendsL:[],equalities:[],distinctIntersections:[]},n=t.map(s=>({condition:s,distinct:[]}));return e.forEach((s,i)=>{let a=!1,c=n.map((p,l)=>{if(a||!p.distinct)return null;let d=p.condition,b=ve(s,d,r);return D(b)?null:b===s?(o.lExtendsR.push(i),a=!0,null):b===d?(o.rExtendsL.push(l),p.distinct=null,null):j(b)?(o.equalities.push([i,l]),a=!0,p.distinct=null,null):U(b,"object")?b:m(`Unexpected predicate intersection result of type '${y(b)}'`)});if(!a)for(let p=0;p<n.length;p++)c[p]&&n[p].distinct?.push(c[p])}),o.distinctIntersections=n.flatMap(s=>s.distinct??[]),o},wt=e=>"rules"in e,xe=(e,t)=>{if(wt(e)){let r=xt(e.rules,t);if(e.morph)if(typeof e.morph=="function")r.push(["morph",e.morph]);else for(let o of e.morph)r.push(["morph",o]);return r}return xt(e,t)},vr=e=>e.rules??e,ve=(e,t,r)=>{let o=vr(e),n=vr(t),s=xr(o,n,r);return"morph"in e?"morph"in t?e.morph===t.morph?j(s)||D(s)?s:{rules:s,morph:e.morph}:r.lastOperator==="&"?u(Me(r.path,"Intersection","of morphs")):{}:D(s)?s:{rules:j(s)?e.rules:s,morph:e.morph}:"morph"in t?D(s)?s:{rules:j(s)?t.rules:s,morph:t.morph}:s};var Or=e=>`${e==="/"?"A":`At ${e}, a`} union including one or more morphs must be discriminatable`;var Pr=(e,t)=>{let r=Yo(e,t),o=e.map((n,s)=>s);return jr(e,o,r,t)},jr=(e,t,r,o)=>{if(t.length===1)return xe(e[t[0]],o);let n=tn(t,r);if(!n)return[["branches",t.map(i=>$t(e[i],o.type.scope)?u(Or(`${o.path}`)):xe(e[i],o))]];let s={};for(let i in n.indexCases){let a=n.indexCases[i];s[i]=jr(e,a,r,o),i!=="default"&&we(s[i],n.path,n,o)}return[["switch",{path:n.path,kind:n.kind,cases:s}]]},we=(e,t,r,o)=>{for(let n=0;n<e.length;n++){let[s,i]=e[n];if(t.length){if((s==="requiredProp"||s==="prerequisiteProp"||s==="optionalProp")&&i[0]===t[0]){if(typeof i[1]=="string"){if(r.kind!=="domain")return Ot(r);e.splice(n,1);return}we(i[1],t.slice(1),r,o),i[1].length===0&&e.splice(n,1);return}}else if(r.kind==="domain"){if(s==="domain"||s==="domains"){e.splice(n,1);return}else if(s==="class"||s==="value")return}else if(r.kind===s){e.splice(n,1);return}if(s==="domains"){if(Ht(i)!==1||!i.object)return Ot(r);we(i.object,t,r,o);return}else if(s==="switch"){for(let a in i.cases)we(i.cases[a],t,r,o);return}else if(s==="branches"){for(let a of i)we(a,t,r,o);return}}return Ot(r)},Ot=e=>m(`Unexpectedly failed to discriminate ${e.kind} at path '${e.path}'`),Xo={domain:!0,class:!0,value:!0},Yo=(e,t)=>{let r={disjointsByPair:{},casesByDisjoint:{}};for(let o=0;o<e.length-1;o++)for(let n=o+1;n<e.length;n++){let s=`${o}/${n}`,i=[];r.disjointsByPair[s]=i;let a=new z(t.type,"|");ve(e[o],e[n],a);for(let c in a.disjoints){if(c.includes(T.index))continue;let{l:p,r:l,kind:d,lOptional:b,rOptional:je}=a.disjoints[c];if(!$(d,Xo)||b||je)continue;let I=$r(d,p),E=$r(d,l);if(I===void 0||E===void 0)continue;let Y=c==="/"?d:`${c}/${d}`;if(i.push(Y),!r.casesByDisjoint[Y]){r.casesByDisjoint[Y]={[I]:[o],[E]:[n]};continue}let G=r.casesByDisjoint[Y],nt=G[I];nt?nt.includes(o)||nt.push(o):G[I]=[o];let st=G[E];st?st.includes(n)||st.push(n):G[E]=[n]}}return r},en=e=>{let t=w.fromString(e);return[t,t.pop()]},tn=(e,t)=>{let r;for(let o=0;o<e.length-1;o++){let n=e[o];for(let s=o+1;s<e.length;s++){let i=e[s],a=t.disjointsByPair[`${n}/${i}`];for(let c of a){let p=t.casesByDisjoint[c],l={},d=[...e],b=0;for(let I in p){let E=p[I].filter(Y=>{let G=e.indexOf(Y);if(G!==-1)return delete d[G],!0});E.length!==0&&(l[I]=E,b++)}let je=f(d);if(je.length&&(l.default=je.map(I=>parseInt(I))),!r||b>r.score){let[I,E]=en(c);if(r={path:I,kind:E,indexCases:l,score:b},b===e.length)return r}}}}return r},$r=(e,t)=>{switch(e){case"value":return Rr(t);case"domain":return t;case"class":return Ne(t);default:return}},Rr=e=>{let t=y(e);return t==="object"||t==="symbol"?void 0:mt(e)},rn={value:e=>Rr(e)??"default",class:e=>oe(e)??"default",domain:y},Ir=(e,t)=>rn[e](t),$t=(e,t)=>"morph"in e?!0:"props"in e?Object.values(e.props).some(r=>on(_(r),t)):!1,on=(e,t)=>typeof e=="string"?t.resolve(e).includesMorph:Object.values(t.resolveTypeNode(e)).some(r=>r===!0?!1:q(r)?r.some(o=>$t(o,t)):$t(r,t));var se=e=>e===!0?{}:e,Dr=(e,t,r)=>{if(e===!0&&t===!0)return x();if(!q(e)&&!q(t)){let i=ve(se(e),se(t),r);return i===e?e:i===t?t:i}let o=B(se(e)),n=B(se(t)),s=wr(o,n,r);return s.equalities.length===o.length&&s.equalities.length===n.length?x():s.lExtendsR.length+s.equalities.length===o.length?e:s.rExtendsL.length+s.equalities.length===n.length?t:s},kr=(e,t,r,o)=>{o.domain=e;let n=Dr(t,r,o);if(!vt(n))return n;let s=[...n.distinctIntersections,...n.equalities.map(i=>n.lBranches[i[0]]),...n.lExtendsR.map(i=>n.lBranches[i]),...n.rExtendsL.map(i=>n.rBranches[i])];return s.length===0&&o.addDisjoint("union",n.lBranches,n.rBranches),s.length===1?s[0]:s},Br=(e,t,r,o)=>{let n=new z(o,"|"),s=Dr(t,r,n);if(!vt(s))return j(s)||s===t?r:s===r?t:e==="boolean"?!0:[se(t),se(r)];let i=[...s.lBranches.filter((a,c)=>!s.lExtendsR.includes(c)&&!s.equalities.some(p=>p[0]===c)),...s.rBranches.filter((a,c)=>!s.rExtendsL.includes(c)&&!s.equalities.some(p=>p[1]===c))];return i.length===1?i[0]:i},Pt=(e,t)=>e===!0?[]:q(e)?Pr(e,t):xe(e,t),Cr=e=>typeof e=="object"&&"value"in e;var Oe=e=>"config"in e,Ke=(e,t,r)=>{r.domain=void 0;let o=r.type.scope.resolveTypeNode(e),n=r.type.scope.resolveTypeNode(t),s=nn(o,n,r);return typeof s=="object"&&!le(s)?le(r.disjoints)?or():r.addDisjoint("domain",f(o),f(n)):s===o?e:s===n?t:s},nn=re((e,t,r,o)=>{if(t===void 0)return r===void 0?m(Ce):void 0;if(r!==void 0)return kr(e,t,r,o)},{onEmpty:"omit"}),W=(e,t,r)=>{let o=new z(r,"&"),n=Ke(e,t,o);return D(n)?u(sr(o.disjoints)):j(n)?e:n},ze=(e,t,r)=>{let o=r.scope.resolveTypeNode(e),n=r.scope.resolveTypeNode(t),s={},i=f({...o,...n});for(let a of i)s[a]=ee(o,a)?ee(n,a)?Br(a,o[a],n[a],r):o[a]:ee(n,a)?n[a]:m(Ce);return s},sn=e=>e[0]&&(e[0][0]==="value"||e[0][0]==="class"),jt=e=>{let t={type:e,path:new w,lastDomain:"undefined"};return C(e.node,t)},C=(e,t)=>{if(typeof e=="string")return t.type.scope.resolve(e).flat;let r=Oe(e),o=an(r?e.node:e,t);return r?[["config",{config:Vt(e.config),node:o}]]:o},an=(e,t)=>{let r=f(e);if(r.length===1){let n=r[0],s=e[n];if(s===!0)return n;t.lastDomain=n;let i=Pt(s,t);return sn(i)?i:[["domain",n],...i]}let o={};for(let n of r)t.lastDomain=n,o[n]=Pt(e[n],t);return[["domains",o]]},Se=(e,t)=>cn(e,t)&&Cr(e[t]),cn=(e,t)=>{let r=f(e);return r.length===1&&r[0]===t},ie=e=>({object:{class:Array,props:{[T.index]:e}}});function Rt(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var g=class e{shift(){return this.chars[this.i++]??""}get lookahead(){return this.chars[this.i]??""}shiftUntil(t){let r="";for(;this.lookahead;){if(t(this,r))if(r[r.length-1]===e.escapeToken)r=r.slice(0,-1);else break;r+=this.shift()}return r}shiftUntilNextTerminator(){return this.shiftUntil(e.lookaheadIsNotWhitespace),this.shiftUntil(e.lookaheadIsTerminator)}get unscanned(){return this.chars.slice(this.i,this.chars.length).join("")}lookaheadIs(t){return this.lookahead===t}lookaheadIsIn(t){return this.lookahead in t}constructor(t){Rt(this,"chars",void 0),Rt(this,"i",void 0),Rt(this,"finalized",!1),this.chars=[...t],this.i=0}};(function(e){var t=e.lookaheadIsTerminator=b=>b.lookahead in n,r=e.lookaheadIsNotWhitespace=b=>b.lookahead!==d,o=e.comparatorStartChars={"<":!0,">":!0,"=":!0},n=e.terminatingChars={...o,"|":!0,"&":!0,")":!0,"[":!0,"%":!0," ":!0},s=e.comparators={"<":!0,">":!0,"<=":!0,">=":!0,"==":!0},i=e.oneCharComparators={"<":!0,">":!0},a=e.comparatorDescriptions={"<":"less than",">":"more than","<=":"at most",">=":"at least","==":"exactly"},c=e.invertedComparators={"<":">",">":"<","<=":">=",">=":"<=","==":"=="},p=e.branchTokens={"|":!0,"&":!0},l=e.escapeToken="\\",d=e.whiteSpaceToken=" "})(g||(g={}));function pn(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}function ln(e,t){return t.get?t.get.call(e):t.value}function un(e,t,r){if(t.set)t.set.call(e,r);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=r}}function Tr(e,t,r){if(!t.has(e))throw new TypeError("attempted to "+r+" private field on non-instance");return t.get(e)}function qe(e,t){var r=Tr(e,t,"get");return ln(e,r)}function mn(e,t,r){pn(e,t),t.set(e,r)}function fn(e,t,r){var o=Tr(e,t,"set");return un(e,o,r),r}function A(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var Dt=class extends TypeError{constructor(t){super(`${t}`),A(this,"cause",void 0),this.cause=t}},J=class{toString(){return this.message}get message(){return this.writers.addContext(this.reason,this.path)}get reason(){return this.writers.writeReason(this.mustBe,new Fe(this.data))}get mustBe(){return typeof this.writers.mustBe=="string"?this.writers.mustBe:this.writers.mustBe(this.source)}constructor(t,r,o,n,s){A(this,"code",void 0),A(this,"path",void 0),A(this,"data",void 0),A(this,"source",void 0),A(this,"writers",void 0),A(this,"parts",void 0),this.code=t,this.path=r,this.data=o,this.source=n,this.writers=s,this.code==="multi"&&(this.parts=this.source)}},ae=new WeakMap,kt=class extends Array{mustBe(t,r){return this.add("custom",t,r)}add(t,r,o){let n=w.from(o?.path??qe(this,ae).path),s=o&&"data"in o?o.data:qe(this,ae).data,i=new J(t,n,s,r,qe(this,ae).getProblemConfig(t));return this.addProblem(i),i}addProblem(t){let r=`${t.path}`,o=this.byPath[r];if(o)if(o.parts)o.parts.push(t);else{let n=new J("multi",o.path,o.data,[o,t],qe(this,ae).getProblemConfig("multi")),s=this.indexOf(o);this[s===-1?this.length:s]=n,this.byPath[r]=n}else this.byPath[r]=t,this.push(t);this.count++}get summary(){return`${this}`}toString(){return this.join(`
`)}throw(){throw new Dt(this)}constructor(t){super(),A(this,"byPath",{}),A(this,"count",0),mn(this,ae,{writable:!0,value:void 0}),fn(this,ae,t)}},_e=kt,dn=e=>e[0].toUpperCase()+e.slice(1),Bt=e=>e.map(t=>ct[t]),Mr=e=>e.map(t=>dt[t]),It=e=>{if(e.length===0)return"never";if(e.length===1)return e[0];let t="";for(let r=0;r<e.length-1;r++)t+=e[r],r<e.length-2&&(t+=", ");return t+=` or ${e[e.length-1]}`,t},V=(e,t)=>`must be ${e}${t&&` (was ${t})`}`,Nr=(e,t)=>t.length===0?dn(e):t.length===1&&ue(t[0])?`Item at index ${t[0]} ${e}`:`${t} ${e}`,H={divisor:{mustBe:e=>e===1?"an integer":`a multiple of ${e}`},class:{mustBe:e=>{let t=Ne(e);return t?dt[t]:`an instance of ${e.name}`},writeReason:(e,t)=>V(e,t.className)},domain:{mustBe:e=>ct[e],writeReason:(e,t)=>V(e,t.domain)},missing:{mustBe:()=>"defined",writeReason:e=>V(e,"")},extraneous:{mustBe:()=>"removed",writeReason:e=>V(e,"")},bound:{mustBe:e=>`${g.comparatorDescriptions[e.comparator]} ${e.limit}${e.units?` ${e.units}`:""}`,writeReason:(e,t)=>V(e,`${t.size}`)},regex:{mustBe:e=>`a string matching ${e}`},value:{mustBe:h},branches:{mustBe:e=>It(e.map(t=>`${t.path} must be ${t.parts?It(t.parts.map(r=>r.mustBe)):t.mustBe}`)),writeReason:(e,t)=>`${e} (was ${t})`,addContext:(e,t)=>t.length?`At ${t}, ${e}`:e},multi:{mustBe:e=>"\u2022 "+e.map(t=>t.mustBe).join(`
\u2022 `),writeReason:(e,t)=>`${t} must be...
${e}`,addContext:(e,t)=>t.length?`At ${t}, ${e}`:e},custom:{mustBe:e=>e},cases:{mustBe:e=>It(e)}},Er=f(H),hn=()=>{let e={},t;for(t of Er)e[t]={mustBe:H[t].mustBe,writeReason:H[t].writeReason??V,addContext:H[t].addContext??Nr};return e},yn=hn(),Ar=e=>{if(!e)return yn;let t={};for(let r of Er)t[r]={mustBe:e[r]?.mustBe??H[r].mustBe,writeReason:e[r]?.writeReason??H[r].writeReason??e.writeReason??V,addContext:e[r]?.addContext??H[r].addContext??e.addContext??Nr};return t};function gn(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}function bn(e,t){return t.get?t.get.call(e):t.value}function xn(e,t,r){if(t.set)t.set.call(e,r);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=r}}function Fr(e,t,r){if(!t.has(e))throw new TypeError("attempted to "+r+" private field on non-instance");return t.get(e)}function Ct(e,t){var r=Fr(e,t,"get");return bn(e,r)}function vn(e,t,r){gn(e,t),t.set(e,r)}function wn(e,t,r){var o=Fr(e,t,"set");return xn(e,o,r),r}function M(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var On=()=>({mustBe:[],writeReason:[],addContext:[],keys:[]}),$n=["mustBe","writeReason","addContext"],Ur=(e,t)=>{let r=new Tt(t,e);We(e.flat,r);let o=new zr(r);if(r.problems.count)o.problems=r.problems;else{for(let[n,s]of r.entriesToPrune)delete n[s];o.data=r.data}return o},zr=class{constructor(){M(this,"data",void 0),M(this,"problems",void 0)}},$e=new WeakMap,Tt=class{getProblemConfig(t){let r={};for(let o of $n)r[o]=this.traversalConfig[o][0]??this.rootScope.config.codes[t][o];return r}traverseConfig(t,r){for(let n of t)this.traversalConfig[n[0]].unshift(n[1]);let o=We(r,this);for(let n of t)this.traversalConfig[n[0]].shift();return o}traverseKey(t,r){let o=this.data;this.data=this.data[t],this.path.push(t);let n=We(r,this);return this.path.pop(),o[t]!==this.data&&(o[t]=this.data),this.data=o,n}traverseResolution(t){let r=this.type.scope.resolve(t),o=r.qualifiedName,n=this.data,s=U(n,"object");if(s){let c=Ct(this,$e)[o];if(c){if(c.includes(n))return!0;c.push(n)}else Ct(this,$e)[o]=[n]}let i=this.type;this.type=r;let a=We(r.flat,this);return this.type=i,s&&Ct(this,$e)[o].pop(),a}traverseBranches(t){let r=this.failFast;this.failFast=!0;let o=this.problems,n=new _e(this);this.problems=n;let s=this.path,i=this.entriesToPrune,a=!1;for(let c of t)if(this.path=new w,this.entriesToPrune=[],Le(c,this)){a=!0,i.push(...this.entriesToPrune);break}return this.path=s,this.entriesToPrune=i,this.problems=o,this.failFast=r,a||!this.problems.add("branches",n)}constructor(t,r){M(this,"data",void 0),M(this,"type",void 0),M(this,"path",void 0),M(this,"problems",void 0),M(this,"entriesToPrune",void 0),M(this,"failFast",void 0),M(this,"traversalConfig",void 0),M(this,"rootScope",void 0),vn(this,$e,{writable:!0,value:void 0}),this.data=t,this.type=r,this.path=new w,this.problems=new _e(this),this.entriesToPrune=[],this.failFast=!1,this.traversalConfig=On(),wn(this,$e,{}),this.rootScope=r.scope}},We=(e,t)=>typeof e=="string"?y(t.data)===e||!t.problems.add("domain",e):Le(e,t),Le=(e,t)=>{let r=!0;for(let o=0;o<e.length;o++){let[n,s]=e[o],i=Pn[n](s,t);if(r&&(r=i),!r&&(t.failFast||o<e.length-1&&be[n]<be[e[o+1][0]]))return!1}return r},Kr=(e,t)=>e[0]in t.data?t.traverseKey(e[0],e[1]):(t.problems.add("missing",void 0,{path:t.path.concat(e[0]),data:void 0}),!1),Sr=e=>(t,r)=>{let o=!0,n={...t.required};for(let i in r.data)if(t.required[i]?(o=r.traverseKey(i,t.required[i])&&o,delete n[i]):t.optional[i]?o=r.traverseKey(i,t.optional[i])&&o:t.index&&Re.test(i)?o=r.traverseKey(i,t.index)&&o:e==="distilledProps"?r.failFast?r.entriesToPrune.push([r.data,i]):delete r.data[i]:(o=!1,r.problems.add("extraneous",r.data[i],{path:r.path.concat(i)})),!o&&r.failFast)return!1;let s=Object.keys(n);if(s.length){for(let i of s)r.problems.add("missing",void 0,{path:r.path.concat(i)});return!1}return o},Pn={regex:yr,divisor:pr,domains:(e,t)=>{let r=e[y(t.data)];return r?Le(r,t):!t.problems.add("cases",Bt(f(e)))},domain:(e,t)=>y(t.data)===e||!t.problems.add("domain",e),bound:hr,optionalProp:(e,t)=>e[0]in t.data?t.traverseKey(e[0],e[1]):!0,requiredProp:Kr,prerequisiteProp:Kr,indexProp:(e,t)=>{if(!Array.isArray(t.data))return t.problems.add("class",Array),!1;let r=!0;for(let o=0;o<t.data.length;o++)if(r=t.traverseKey(`${o}`,e)&&r,!r&&t.failFast)return!1;return r},branches:(e,t)=>t.traverseBranches(e),switch:(e,t)=>{let r=Jt(t.data,e.path),o=Ir(e.kind,r);if(ee(e.cases,o))return Le(e.cases[o],t);let n=f(e.cases),s=t.path.concat(e.path),i=e.kind==="value"?n:e.kind==="domain"?Bt(n):e.kind==="class"?Mr(n):m(`Unexpectedly encountered rule kind '${e.kind}' during traversal`);return t.problems.add("cases",i,{path:s,data:r}),!1},alias:(e,t)=>t.traverseResolution(e),class:ar,narrow:(e,t)=>{let r=t.problems.count,o=e(t.data,t.problems);return!o&&t.problems.count===r&&t.problems.mustBe(e.name?`valid according to ${e.name}`:"valid"),o},config:({config:e,node:t},r)=>r.traverseConfig(e,t),value:(e,t)=>t.data===e||!t.problems.add("value",e),morph:(e,t)=>{let r=e(t.data,t.problems);if(t.problems.length)return!1;if(r instanceof J)return t.problems.addProblem(r),!1;if(r instanceof zr){if(r.problems){for(let o of r.problems)t.problems.addProblem(o);return!1}return t.data=r.data,!0}return t.data=r,!0},distilledProps:Sr("distilledProps"),strictProps:Sr("strictProps")};var L=new Proxy(()=>L,{get:()=>L});var Mt=(e,t,r,o)=>{let n={node:e,flat:[["alias",e]],allows:a=>!s(a).problems,assert:a=>{let c=s(a);return c.problems?c.problems.throw():c.data},infer:L,inferIn:L,qualifiedName:jn(e)?o.getAnonymousQualifiedName(e):`${o.name}.${e}`,definition:t,scope:o,includesMorph:!1,config:r},s={[e]:a=>Ur(s,a)}[e];return Object.assign(s,n)},Nt=e=>e?.infer===L,jn=e=>e[0]==="\u03BB";var qr=e=>{let t=e.scanner.shiftUntilNextTerminator();e.setRoot(Rn(e,t))},Rn=(e,t)=>e.ctx.type.scope.addParsedReferenceIfResolvable(t,e.ctx)?t:In(t)??e.error(t===""?Et(e):Dn(t)),In=e=>{let t=fe(e);if(t!==void 0)return{number:{value:t}};let r=lt(e);if(r!==void 0)return{bigint:{value:r}}},Dn=e=>`'${e}' is unresolvable`,Et=e=>{let t=e.previousOperator();return t?At(t,e.scanner.unscanned):kn(e.scanner.unscanned)},At=(e,t)=>`Token '${e}' requires a right operand${t?` before '${t}'`:""}`,kn=e=>`Expected an expression${e?` before '${e}'`:""}`;var Kt=(e,t)=>({node:t.type.scope.resolveTypeNode(v(e[0],t)),config:e[2]});var R=e=>Object.isFrozen(e)?e:Array.isArray(e)?Object.freeze(e.map(R)):Bn(e),Bn=e=>{for(let t in e)R(e[t]);return e};var Cn=R({regex:me.source}),Tn=R({range:{min:{comparator:">=",limit:0}},divisor:1}),_r=(e,t)=>{let r=t.type.scope.resolveNode(v(e[1],t)),o=f(r).map(l=>Nn(l,r[l])),n=Wr(o);if(!n.length)return Me(t.path,"keyof");let s={};for(let l of n){let d=typeof l;if(d==="string"||d==="number"||d==="symbol"){var i,a;(i=s)[a=d]??(i[a]=[]),s[d].push({value:l})}else if(l===me){var c,p;(c=s).string??(c.string=[]),s.string.push(Cn),(p=s).number??(p.number=[]),s.number.push(Tn)}else return m(`Unexpected keyof key '${h(l)}'`)}return Object.fromEntries(Object.entries(s).map(([l,d])=>[l,d.length===1?d[0]:d]))},Mn={bigint:Z(0n),boolean:Z(!1),null:[],number:Z(0),object:[],string:Z(""),symbol:Z(Symbol()),undefined:[]},Nn=(e,t)=>e!=="object"||t===!0?Mn[e]:Wr(B(t).map(r=>En(r))),Wr=e=>{if(!e.length)return[];let t=e[0];for(let r=1;r<e.length;r++)t=t.filter(o=>e[r].includes(o));return t},En=e=>{let t=[];if("props"in e)for(let r of Object.keys(e.props))r===T.index?t.push(me):t.includes(r)||(t.push(r),me.test(r)&&t.push(Ie(r,`Unexpectedly failed to parse an integer from key '${r}'`)));if("class"in e){let r=typeof e.class=="string"?de[e.class]:e.class;for(let o of Z(r.prototype))t.includes(o)||t.push(o)}return t};var Gr=(e,t)=>{if(typeof e[2]!="function")return u(An(e[2]));let r=v(e[0],t),o=t.type.scope.resolveTypeNode(r),n=e[2];t.type.includesMorph=!0;let s,i={};for(s in o){let a=o[s];a===!0?i[s]={rules:{},morph:n}:typeof a=="object"?i[s]=q(a)?a.map(c=>Lr(c,n)):Lr(a,n):m(`Unexpected predicate value for domain '${s}': ${h(a)}`)}return i},Lr=(e,t)=>wt(e)?{...e,morph:e.morph?Array.isArray(e.morph)?[...e.morph,t]:[e.morph,t]:t}:{rules:e,morph:t},An=e=>`Morph expression requires a function following '|>' (was ${typeof e})`;var Zr=e=>`Expected a Function or Record<Domain, Function> operand (${h(e)} was invalid)`,Vr=(e,t,r,o)=>{let n=f(t);if(!U(e,"object"))return u(Zr(e));let s={};if(typeof e=="function"){let i={[o]:e};for(let a of n)s[a]=i}else for(let i of n){if(e[i]===void 0)continue;let a={[o]:e[i]};if(typeof a[o]!="function")return u(Zr(a));s[i]=a}return s};var Hr=(e,t)=>{let r=v(e[0],t),o=t.type.scope.resolveNode(r),n=Oe(o),s=n?o.node:o,i=W(r,Vr(e[2],s,t,"narrow"),t.type);return n?{config:o.config,node:i}:i};var Qr=(e,t)=>{if(Sn(e))return Xr[e[1]](e,t);if(Fn(e))return Yr[e[0]](e,t);let r={length:["!",{number:{value:e.length}}]};for(let o=0;o<e.length;o++)t.path.push(`${o}`),r[o]=v(e[o],t),t.path.pop();return{object:{class:Array,props:r}}},Jr=(e,t)=>{if(e[2]===void 0)return u(At(e[1],""));let r=v(e[0],t),o=v(e[2],t);return e[1]==="&"?W(r,o,t.type):ze(r,o,t.type)},Kn=(e,t)=>ie(v(e[0],t));var Sn=e=>Xr[e[1]]!==void 0,Xr={"|":Jr,"&":Jr,"[]":Kn,"=>":Hr,"|>":Gr,":":Kt},Yr={keyof:_r,instanceof:e=>typeof e[1]!="function"?u(`Expected a constructor following 'instanceof' operator (was ${typeof e[1]}).`):{object:{class:e[1]}},"===":e=>({[y(e[1])]:{value:e[1]}}),node:e=>e[1]},Fn=e=>Yr[e[0]]!==void 0;var eo=(e,t)=>{let r={};for(let o in e){let n=o,s=!1;o[o.length-1]==="?"&&(o[o.length-2]===g.escapeToken?n=`${o.slice(0,-2)}?`:(n=o.slice(0,-1),s=!0)),t.path.push(n);let i=v(e[o],t);t.path.pop(),r[n]=s?["?",i]:i}return{object:{props:r}}};var to=e=>`Unmatched )${e===""?"":` before ${e}`}`,ro="Missing )",oo=(e,t)=>`Left bounds are only valid when paired with right bounds (try ...${t}${e})`,Ge=e=>`Left-bounded expressions must specify their limits using < or <= (was ${e})`,no=(e,t,r,o)=>`An expression may have at most one left bound (parsed ${e}${g.invertedComparators[t]}, ${r}${g.invertedComparators[o]})`;function Pe(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var Ze=class{error(t){return u(t)}hasRoot(){return this.root!==void 0}resolveRoot(){return this.assertHasRoot(),this.ctx.type.scope.resolveTypeNode(this.root)}rootToString(){return this.assertHasRoot(),h(this.root)}ejectRootIfLimit(){this.assertHasRoot();let t=typeof this.root=="string"?this.ctx.type.scope.resolveNode(this.root):this.root;if(Se(t,"number")){let r=t.number.value;return this.root=void 0,r}}ejectRangeIfOpen(){if(this.branches.range){let t=this.branches.range;return delete this.branches.range,t}}assertHasRoot(){if(this.root===void 0)return m("Unexpected interaction with unset root")}assertUnsetRoot(){if(this.root!==void 0)return m("Unexpected attempt to overwrite root")}setRoot(t){this.assertUnsetRoot(),this.root=t}rootToArray(){this.root=ie(this.ejectRoot())}intersect(t){this.root=W(this.ejectRoot(),t,this.ctx.type)}ejectRoot(){this.assertHasRoot();let t=this.root;return this.root=void 0,t}ejectFinalizedRoot(){this.assertHasRoot();let t=this.root;return this.root=Un,t}finalize(){if(this.groups.length)return this.error(ro);this.finalizeBranches(),this.scanner.finalized=!0}reduceLeftBound(t,r){let o=g.invertedComparators[r];if(!$(o,Ue))return this.error(Ge(r));if(this.branches.range)return this.error(no(`${this.branches.range.limit}`,this.branches.range.comparator,`${t}`,o));this.branches.range={limit:t,comparator:o}}finalizeBranches(){this.assertRangeUnset(),this.branches.union?(this.pushRootToBranch("|"),this.setRoot(this.branches.union)):this.branches.intersection&&this.setRoot(W(this.branches.intersection,this.ejectRoot(),this.ctx.type))}finalizeGroup(){this.finalizeBranches();let t=this.groups.pop();if(!t)return this.error(to(this.scanner.unscanned));this.branches=t}pushRootToBranch(t){this.assertRangeUnset(),this.branches.intersection=this.branches.intersection?W(this.branches.intersection,this.ejectRoot(),this.ctx.type):this.ejectRoot(),t==="|"&&(this.branches.union=this.branches.union?ze(this.branches.union,this.branches.intersection,this.ctx.type):this.branches.intersection,delete this.branches.intersection)}assertRangeUnset(){if(this.branches.range)return this.error(oo(`${this.branches.range.limit}`,this.branches.range.comparator))}reduceGroupOpen(){this.groups.push(this.branches),this.branches={}}previousOperator(){return this.branches.range?.comparator??this.branches.intersection?"&":this.branches.union?"|":void 0}shiftedByOne(){return this.scanner.shift(),this}constructor(t,r){Pe(this,"ctx",void 0),Pe(this,"scanner",void 0),Pe(this,"root",void 0),Pe(this,"branches",void 0),Pe(this,"groups",void 0),this.ctx=r,this.branches={},this.groups=[],this.scanner=new g(t)}},Un=new Proxy({},{get:()=>m("Unexpected attempt to access ejected attributes")});var so=(e,t)=>{let r=e.scanner.shiftUntil(zn[t]);if(e.scanner.lookahead==="")return e.error(_n(r,t));e.scanner.shift()==="/"?(bt(r),e.setRoot({string:{regex:r}})):e.setRoot({string:{value:r}})},io={"'":1,'"':1,"/":1},zn={"'":e=>e.lookahead==="'",'"':e=>e.lookahead==='"',"/":e=>e.lookahead==="/"},qn={'"':"double-quote","'":"single-quote","/":"forward slash"},_n=(e,t)=>`${t}${e} requires a closing ${qn[t]}`;var Ve=e=>e.scanner.lookahead===""?e.error(Et(e)):e.scanner.lookahead==="("?e.shiftedByOne().reduceGroupOpen():e.scanner.lookaheadIsIn(io)?so(e,e.scanner.shift()):e.scanner.lookahead===" "?Ve(e.shiftedByOne()):qr(e);var ao=e=>`Bounded expression ${e} must be a number, string or array`;var co=(e,t)=>{let r=Wn(e,t),o=e.ejectRootIfLimit();return o===void 0?Gn(e,r):e.reduceLeftBound(o,r)},Wn=(e,t)=>e.scanner.lookaheadIs("=")?`${t}${e.scanner.shift()}`:$(t,g.oneCharComparators)?t:e.error(Ln),Ln="= is not a valid comparator. Use == to check for equality",Gn=(e,t)=>{let r=e.scanner.shiftUntilNextTerminator(),o=fe(r,Hn(t,r+e.scanner.unscanned)),n=e.ejectRangeIfOpen(),s={comparator:t,limit:o},i=n?St(s,yt)?ne("min",n,s)==="l"?e.error(Jn({min:n,max:s})):{min:n,max:s}:e.error(Ge(t)):Vn(s,"==")?s:St(s,Ue)?{min:s}:St(s,yt)?{max:s}:m(`Unexpected comparator '${s.comparator}'`);e.intersect(Zn(i,e))},Zn=(e,t)=>{let r=t.resolveRoot(),o=f(r),n={},s={range:e};return o.every(a=>{switch(a){case"string":return n.string=s,!0;case"number":return n.number=s,!0;case"object":return n.object=s,r.object===!0?!1:B(r.object).every(c=>"class"in c&&c.class===Array);default:return!1}})||t.error(ao(t.rootToString())),n},Vn=(e,t)=>e.comparator===t,St=(e,t)=>e.comparator in t,Hn=(e,t)=>`Comparator ${e} must be followed by a number literal (was '${t}')`,Jn=e=>`${Be(e)} is empty`;var po=e=>`Divisibility operand ${e} must be a number`;var uo=e=>{let t=e.scanner.shiftUntilNextTerminator(),r=Ie(t,lo(t));r===0&&e.error(lo(0));let o=f(e.resolveRoot());o.length===1&&o[0]==="number"?e.intersect({number:{divisor:r}}):e.error(po(e.rootToString()))},lo=e=>`% operator must be followed by a non-zero integer literal (was ${e})`;var Ft=e=>{let t=e.scanner.shift();return t===""?e.finalize():t==="["?e.scanner.shift()==="]"?e.rootToArray():e.error(Xn):$(t,g.branchTokens)?e.pushRootToBranch(t):t===")"?e.finalizeGroup():$(t,g.comparatorStartChars)?co(e,t):t==="%"?uo(e):t===" "?Ft(e):m(Qn(t))},Qn=e=>`Unexpected character '${e}'`,Xn="Missing expected ']'";var mo=(e,t)=>t.type.scope.parseCache.get(e)??t.type.scope.parseCache.set(e,Yn(e,t)??es(e,t)),Yn=(e,t)=>{if(t.type.scope.addParsedReferenceIfResolvable(e,t))return e;if(e.endsWith("[]")){let r=e.slice(0,-2);if(t.type.scope.addParsedReferenceIfResolvable(e,t))return ie(r)}},es=(e,t)=>{let r=new Ze(e,t);return Ve(r),ts(r)},ts=e=>{for(;!e.scanner.finalized;)rs(e);return e.ejectFinalizedRoot()},rs=e=>e.hasRoot()?Ft(e):Ve(e);var v=(e,t)=>{let r=y(e);if(r==="string")return mo(e,t);if(r!=="object")return u(Ut(r));let o=oe(e);switch(o){case"Object":return eo(e,t);case"Array":return Qr(e,t);case"RegExp":return{string:{regex:e.source}};case"Function":if(Nt(e))return t.type.scope.addAnonymousTypeReference(e,t);if(os(e)){let n=e();if(Nt(n))return t.type.scope.addAnonymousTypeReference(n,t)}return u(Ut("Function"));default:return u(Ut(o??h(e)))}},vp=Symbol("as"),os=e=>typeof e=="function"&&e.length===0,Ut=e=>`Type definitions must be strings or objects (was ${e})`;function ns(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var ce=class{get root(){return this.cache}has(t){return t in this.cache}get(t){return this.cache[t]}set(t,r){return this.cache[t]=r,r}constructor(){ns(this,"cache",{})}},He=class extends ce{set(t,r){return this.cache[t]=R(r),r}};function bo(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}function ss(e,t){return t.get?t.get.call(e):t.value}function is(e,t,r){if(t.set)t.set.call(e,r);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=r}}function xo(e,t,r){if(!t.has(e))throw new TypeError("attempted to "+r+" private field on non-instance");return t.get(e)}function S(e,t){var r=xo(e,t,"get");return ss(e,r)}function fo(e,t,r){bo(e,t),t.set(e,r)}function ho(e,t,r){var o=xo(e,t,"set");return is(e,o,r),r}function K(e,t,r){if(!t.has(e))throw new TypeError("attempted to get private field on non-instance");return r}function Je(e,t){bo(e,t),t.add(e)}function O(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var as=e=>({codes:Ar(e.codes),keys:e.keys??"loose"}),cs=0,yo={},zt={};var Q=new WeakMap,pe=new WeakMap,go=new WeakSet,Qe=new WeakSet,_t=new WeakSet,Xe=new WeakSet,Wt=class{getAnonymousQualifiedName(t){let r=0,o=t;for(;this.isResolvable(o);)o=`${t}${r++}`;return`${this.name}.${o}`}addAnonymousTypeReference(t,r){var o;return(o=r.type).includesMorph||(o.includesMorph=t.includesMorph),t.node}get infer(){return L}compile(){if(!zt[this.name]){for(let t in this.aliases)this.resolve(t);zt[this.name]=S(this,pe).root}return S(this,pe).root}addParsedReferenceIfResolvable(t,r){var o;let n=K(this,Xe,Lt).call(this,t,"undefined",[t]);return n?((o=r.type).includesMorph||(o.includesMorph=n.includesMorph),!0):!1}resolve(t){return K(this,Xe,Lt).call(this,t,"throw",[t])}resolveNode(t){return typeof t=="string"?this.resolveNode(this.resolve(t).node):t}resolveTypeNode(t){let r=this.resolveNode(t);return Oe(r)?r.node:r}isResolvable(t){return S(this,Q).has(t)||this.aliases[t]}constructor(t,r={}){Je(this,go),Je(this,Qe),Je(this,_t),Je(this,Xe),O(this,"aliases",void 0),O(this,"name",void 0),O(this,"config",void 0),O(this,"parseCache",void 0),fo(this,Q,{writable:!0,value:void 0}),fo(this,pe,{writable:!0,value:void 0}),O(this,"expressions",void 0),O(this,"intersection",void 0),O(this,"union",void 0),O(this,"arrayOf",void 0),O(this,"keyOf",void 0),O(this,"valueOf",void 0),O(this,"instanceOf",void 0),O(this,"narrow",void 0),O(this,"morph",void 0),O(this,"type",void 0),this.aliases=t,this.parseCache=new He,ho(this,Q,new ce),ho(this,pe,new ce),this.expressions={intersection:(o,n,s)=>this.type([o,"&",n],s),union:(o,n,s)=>this.type([o,"|",n],s),arrayOf:(o,n)=>this.type([o,"[]"],n),keyOf:(o,n)=>this.type(["keyof",o],n),node:(o,n)=>this.type(["node",o],n),instanceOf:(o,n)=>this.type(["instanceof",o],n),valueOf:(o,n)=>this.type(["===",o],n),narrow:(o,n,s)=>this.type([o,"=>",n],s),morph:(o,n,s)=>this.type([o,"|>",n],s)},this.intersection=this.expressions.intersection,this.union=this.expressions.union,this.arrayOf=this.expressions.arrayOf,this.keyOf=this.expressions.keyOf,this.valueOf=this.expressions.valueOf,this.instanceOf=this.expressions.instanceOf,this.narrow=this.expressions.narrow,this.morph=this.expressions.morph,this.type=Object.assign((o,n={})=>{let s=Mt("\u03BBtype",o,n,this),i=K(this,_t,vo).call(this,s),a=v(o,i);return s.node=R(le(n)?{config:n,node:this.resolveTypeNode(a)}:a),s.flat=R(jt(s)),s},{from:this.expressions.node}),this.name=K(this,go,ps).call(this,r),r.standard!==!1&&K(this,Qe,qt).call(this,[zt.standard],"imports"),r.imports&&K(this,Qe,qt).call(this,r.imports,"imports"),r.includes&&K(this,Qe,qt).call(this,r.includes,"includes"),this.config=as(r)}};function ps(e){let t=e.name?yo[e.name]?u(`A scope named '${e.name}' already exists`):e.name:`scope${++cs}`;return yo[t]=this,t}function qt(e,t){for(let r of e)for(let o in r)(S(this,Q).has(o)||o in this.aliases)&&u(us(o)),S(this,Q).set(o,r[o]),t==="includes"&&S(this,pe).set(o,r[o])}function vo(e){return{type:e,path:new w}}function Lt(e,t,r){let o=S(this,Q).get(e);if(o)return o;let n=this.aliases[e];if(!n)return t==="throw"?m(`Unexpectedly failed to resolve alias '${e}'`):void 0;let s=Mt(e,n,{},this),i=K(this,_t,vo).call(this,s);S(this,Q).set(e,s),S(this,pe).set(e,s);let a=v(n,i);if(typeof a=="string"){if(r.includes(a))return u(ls(e,r));r.push(a),a=K(this,Xe,Lt).call(this,a,"throw",r).node}return s.node=R(a),s.flat=R(jt(s)),s}var N=(e,t={})=>new Wt(e,t),Gt=N({},{name:"root",standard:!1}),k=Gt.type,ls=(e,t)=>`Alias '${e}' has a shallow resolution cycle: ${[...t,e].join("=>")}`,us=e=>`Alias '${e}' is already defined`;var Ye=N({Function:["node",{object:{class:Function}}],Date:["node",{object:{class:Date}}],Error:["node",{object:{class:Error}}],Map:["node",{object:{class:Map}}],RegExp:["node",{object:{class:RegExp}}],Set:["node",{object:{class:Set}}],WeakMap:["node",{object:{class:WeakMap}}],WeakSet:["node",{object:{class:WeakSet}}],Promise:["node",{object:{class:Promise}}]},{name:"jsObjects",standard:!1}),wo=Ye.compile();var Oo={bigint:!0,boolean:!0,null:!0,number:!0,object:!0,string:!0,symbol:!0,undefined:!0},et=N({any:["node",Oo],bigint:["node",{bigint:!0}],boolean:["node",{boolean:!0}],false:["node",{boolean:{value:!1}}],never:["node",{}],null:["node",{null:!0}],number:["node",{number:!0}],object:["node",{object:!0}],string:["node",{string:!0}],symbol:["node",{symbol:!0}],true:["node",{boolean:{value:!0}}],unknown:["node",Oo],void:["node",{undefined:!0}],undefined:["node",{undefined:!0}]},{name:"ts",standard:!1}),X=et.compile();var ms=e=>{let t=e.replace(/[- ]+/g,""),r=0,o,n,s;for(let i=t.length-1;i>=0;i--)o=t.substring(i,i+1),n=parseInt(o,10),s?(n*=2,n>=10?r+=n%10+1:r+=n):r+=n,s=!s;return!!(r%10===0&&t)},fs=/^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/,$o=k([fs,"=>",(e,t)=>ms(e)||!t.mustBe("a valid credit card number")],{mustBe:"a valid credit card number"});var ds=/^[./-]$/,hs=/^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/,ys=e=>!isNaN(e),tt=e=>`a ${e}-formatted date`,gs=(e,t)=>{if(!t?.format){let a=new Date(e);return ys(a)?a:"a valid date"}if(t.format==="iso8601")return hs.test(e)?new Date(e):tt("iso8601");let r=e.split(ds),o=e[r[0].length],n=o?t.format.split(o):[t.format];if(r.length!==n.length)return tt(t.format);let s={};for(let a=0;a<n.length;a++){if(r[a].length!==n[a].length&&!(n[a].length===1&&r[a].length===2))return tt(t.format);s[n[a][0]]=r[a]}let i=new Date(`${s.m}/${s.d}/${s.y}`);return`${i.getDate()}`===s.d?i:tt(t.format)},Po=k([X.string,"|>",(e,t)=>{let r=gs(e);return typeof r=="string"?t.mustBe(r):r}]);var bs=k([pt,"|>",e=>parseFloat(e)],{mustBe:"a well-formed numeric string"}),xs=k([X.string,"|>",(e,t)=>{if(!ue(e))return t.mustBe("a well-formed integer string");let r=parseInt(e);return Number.isSafeInteger(r)?r:t.mustBe("an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER")}]),vs=k(/^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/,{mustBe:"a valid email"}),ws=k(/^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/,{mustBe:"a valid UUID"}),Os=k(/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/,{mustBe:"a valid semantic version (see https://semver.org/)"}),$s=k([X.string,"|>",e=>JSON.parse(e)],{mustBe:"a JSON-parsable string"}),rt=N({alpha:[/^[A-Za-z]*$/,":",{mustBe:"only letters"}],alphanumeric:[/^[A-Za-z\d]*$/,":",{mustBe:"only letters and digits"}],lowercase:[/^[a-z]*$/,":",{mustBe:"only lowercase letters"}],uppercase:[/^[A-Z]*$/,":",{mustBe:"only uppercase letters"}],creditCard:$o,email:vs,uuid:ws,parsedNumber:bs,parsedInteger:xs,parsedDate:Po,semver:Os,json:$s,integer:["node",{number:{divisor:1}}]},{name:"validation",standard:!1}),jo=rt.compile();var ot=N({},{name:"standard",includes:[X,wo,jo],standard:!1}),Ps=ot.compile(),F={root:Gt,tsKeywords:et,jsObjects:Ye,validation:rt,ark:ot};var Zt=ot.type;var js=F.ark.intersection,Rs=F.ark.union,Is=F.ark.arrayOf,Ds=F.ark.keyOf,ks=F.ark.instanceOf,Bs=F.ark.valueOf,Cs=F.ark.narrow,Ts=F.ark.morph;var fl=Zt({name:"string",age:"number"});export{fl as T};
