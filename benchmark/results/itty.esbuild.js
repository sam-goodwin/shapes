var p=class{props;constructor(e){typeof e=="string"?this.props={kind:e}:this.props=e,Object.assign(this,e)}clone(e){return new this.constructor({...this,...e})}describe(e){return this.clone({description:e})}optional(){return n.union(this,n.undefined())}nullable(){return n.union(this,n.null())}nullish(){return n.union(this,n.null(),n.undefined())}extend(e){return this.kind==="class"?n.class({...this.shape,...e},this):n.object({...this.shape,...e})}merge(e){return this.extend(e.shape)}pick(e,...r){return this.pickOrOmit(typeof e=="string"?[e,...r]:e,!0)}omit(e,...r){return this.pickOrOmit(typeof e=="string"?[e,...r]:e,!1)}pickOrOmit(e,r){let t=new Set(Array.isArray(e)?e:Object.keys(e)),s=Object.fromEntries(Object.entries(this.shape).filter(([i])=>r?t.has(i):!t.has(i)));return this.kind==="class"?n.class(s):n.object(s)}partial(){let e={};for(let[r,t]of Object.entries(this.shape))e[r]=n.union(t,n.undefined());return this.kind==="class"?n.class(e):n.object(e)}deepPartial(){let e=this;if(this.kind==="class"||this.kind==="object"){let r={};for(let[t,s]of Object.entries(e.shape))r[t]=n.union(s,n.undefined());return this.kind==="class"?n.class(r):n.object(r)}else return this.kind==="array"?n.array(e.item.deepPartial()):n.union(e,n.undefined())}keyof(){if(this.kind==="class"||this.kind==="object")return n.enum(...Object.keys(this.shape))}parse(e,r){let t=this.kind;if(t==="object"||t==="class"){let s=this;if(typeof e!="object"||e===null)throw new Error("Expected an object");let i={};for(let[o,c]of Object.entries(s.shape))if(o in e)i[o]=c.parse(e[o],this);else if(!n.isUndefined(c)){if(n.isUnion(c)&&c.options.some(n.isUndefined))continue;throw new Error(`Expected ${o} in object`)}return t==="class"?new this(i):i}else{if(typeof e===t)return e;if(t==="any"||t==="unknown")return e;if(t==="never")throw new Error("Received never");if(t==="void"){if(e!==void 0)throw new Error("Expected void");return e}else{if(t==="bigint"&&typeof e=="number")return BigInt(e);if(t==="literal"){if(this.value!==e)throw new Error("Expected a literal");return e}else if(t==="this"){if(r===void 0)throw new Error("this is undefined");return r.parse(e,r)}else if(t==="array"){if(!Array.isArray(e))throw new Error("Expected an array");return e.map(s=>this.item.parse(s,r))}else if(t==="union"||t==="enum"||t==="nativeEnum"){let s=this;for(let i of s.options)if(t==="enum"||t==="nativeEnum"){if(i===e)return e}else try{return i.parse(e,r)}catch{}throw new Error("Expected one of the union options")}else throw new Error(`Unsupported type ${t.toString()}`)}}}};function a(f){return new Proxy({},{get:(e,r)=>typeof r=="string"&&r.startsWith("is")?t=>t&&(typeof t=="object"||typeof t=="function")&&t.kind===r.slice(2).toLowerCase():r==="coerce"?()=>a({...f,coerce:!0}):r==="describe"?t=>a({...f,description:t}):(...t)=>{let s={...f,kind:r,args:t};r==="union"?s.options=t:r==="enum"?(s.options=t,s.enum=Object.fromEntries(t.map(o=>[o,o]))):r==="nativeEnum"?(s.options=Object.values(t[0]),s.enum=t[0]):r==="literal"?s.value=t[0]:r==="array"?s.item=t[0]:(r==="object"||r==="class")&&(s.shape=t[0]);let i=new p(s);if(r!=="class")return i;{let c=t[1]??class{constructor(h){Object.assign(this,h)}};Object.assign(c,i);for(let u of Object.getOwnPropertyNames(p.prototype)){let h=i[u];typeof h=="function"&&u!=="constructor"&&Object.defineProperty(c,u,{value:h})}return c}}})}var n=a({}),l=n;var d=l.object({name:l.string(),age:l.number()}),y={name:"Alice",age:30},b=d.parse(y);console.log(b);
