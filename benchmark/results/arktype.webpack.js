(()=>{"use strict";class e extends Error{}const t=t=>{throw new e(t)};class n extends Error{}const r=e=>{throw new n(e)},s=(e,t)=>o(e)===t,o=e=>{const t=typeof e;return"object"===t?null===e?"null":"object":"function"===t?"object":t},i={bigint:"a bigint",boolean:"boolean",null:"null",number:"a number",object:"an object",string:"a string",symbol:"a symbol",undefined:"undefined"},a=(e,t)=>e in t,c=e=>Object.keys(e),l=e=>{const t=[];for(;e!==Object.prototype&&null!=e;){for(const n of Object.getOwnPropertyNames(e))t.includes(n)||t.push(n);for(const n of Object.getOwnPropertySymbols(e))t.includes(n)||t.push(n);e=Object.getPrototypeOf(e)}return t},u=(e,t)=>{const n=e?.[t];return null!=n},h=e=>!!s(e,"object")&&0!==Object.keys(e).length,d=(Symbol("id"),e=>Array.isArray(e)?e:[e]);class p extends Array{static fromString(e,t="/"){return e===t?new p:new p(...e.split(t))}toString(e="/"){return this.length?this.join(e):e}}const f=/^(?!^-0$)-?(?:0|[1-9]\d*)(?:\.\d*[1-9])?$/,m=/^-?\d*\.?\d*$/,b=/^(?:0|(?:-?[1-9]\d*))$/,g=e=>b.test(e),v=/^(?:0|(?:[1-9]\d*))$/,y=/^-?\d+$/,w={number:"a number",bigint:"a bigint",integer:"an integer"},$=(e,t)=>`'${e}' was parsed as ${w[t]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`,x=(e,t)=>k(e,"number",t),j=(e,t)=>k(e,"integer",t),k=(e,t,n)=>{const s=((e,t)=>"number"===t?Number(e):Number.parseInt(e))(e,t);if(!Number.isNaN(s)){if(((e,t)=>{return"number"===t?(n=e,f.test(n)):g(e);var n})(e,t))return s;if(((e,t)=>{return"number"===t?0!==(n=e).length&&m.test(n):(e=>y.test(e))(e);var n})(e,t))return r($(e,t))}return n?r(!0===n?`Failed to parse ${w[t]} from '${e}'`:n):void 0},O=(e,t)=>{switch(o(e)){case"object":return JSON.stringify(B(e,R,[]),null,t);case"symbol":return R.onSymbol(e);default:return A(e)}},R={onCycle:()=>"(cycle)",onSymbol:e=>`(symbol${e.description&&` ${e.description}`})`,onFunction:e=>`(function${e.name&&` ${e.name}`})`},B=(e,t,n)=>{switch(o(e)){case"object":if("function"==typeof e)return R.onFunction(e);if(n.includes(e))return"(cycle)";const r=[...n,e];if(Array.isArray(e))return e.map((e=>B(e,t,r)));const s={};for(const n in e)s[n]=B(e[n],t,r);return s;case"symbol":return R.onSymbol(e);case"bigint":return`${e}n`;case"undefined":return"undefined";default:return e}},A=e=>"string"==typeof e?`'${e}'`:"bigint"==typeof e?`${e}n`:`${e}`;function P(e,t,n){if(!t.has(e))throw new TypeError("attempted to "+n+" private field on non-instance");return t.get(e)}function T(e,t){return function(e,t){return t.get?t.get.call(e):t.value}(e,P(e,t,"get"))}function E(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const N=e=>(n,r,s)=>void 0===n?void 0===r?t(S):r:void 0===r?n:e(n,r,s),S="Unexpected operation two undefined operands",C={domain:({l:e,r:t})=>`${e.join(", ")} and ${t.join(", ")}`,range:({l:e,r:t})=>`${D(e)} and ${D(t)}`,class:({l:e,r:t})=>`classes ${"string"==typeof e?e:e.name} and ${"string"==typeof t?t:t.name}`,tupleLength:({l:e,r:t})=>`tuples of length ${e} and ${t}`,value:({l:e,r:t})=>`literal values ${O(e)} and ${O(t)}`,leftAssignability:({l:e,r:t})=>`literal value ${O(e.value)} and ${O(t)}`,rightAssignability:({l:e,r:t})=>`literal value ${O(t.value)} and ${O(e)}`,union:({l:e,r:t})=>`branches ${O(e)} and branches ${O(t)}`},D=e=>"limit"in e?`the range of exactly ${e.limit}`:e.min?e.max?`the range bounded by ${e.min.comparator}${e.min.limit} and ${e.max.comparator}${e.max.limit}`:`${e.min.comparator}${e.min.limit}`:e.max?`${e.max.comparator}${e.max.limit}`:"the unbounded range";var I=new WeakMap;class z{get disjoints(){return T(this,I)}addDisjoint(e,t,n){return T(this,I)[`${this.path}`]={kind:e,l:t,r:n,lOptional:this.lOptional,rOptional:this.rOptional},M}constructor(e,t){var n,r,s;E(this,"type",void 0),E(this,"lastOperator",void 0),E(this,"path",void 0),E(this,"lOptional",void 0),E(this,"rOptional",void 0),E(this,"domain",void 0),s={writable:!0,value:void 0},function(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}(n=this,r=I),r.set(n,s),this.type=e,this.lastOperator=t,this.path=new p,this.lOptional=!1,this.rOptional=!1,function(e,t,n){(function(e,t,n){if(t.set)t.set.call(e,n);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=n}})(e,P(e,t,"set"),n)}(this,I,{})}}const M=Symbol("empty"),q=e=>e===M,F=Symbol("equal"),U=()=>F,W=e=>e===F,Z=(e,t)=>(n,r,s)=>{const o={},i=c({...n,...r});let a=!0,l=!0;for(const c of i){const i="function"==typeof e?e(c,n[c],r[c],s):e[c](n[c],r[c],s);if(W(i))void 0!==n[c]&&(o[c]=n[c]);else if(q(i)){if("omit"!==t.onEmpty)return M;a=!1,l=!1}else void 0!==i&&(o[c]=i),a&&(a=i===n[c]),l&&(l=i===r[c])}return a?l?U():n:l?r:o},L=(e,t,n)=>`${e.length?`At ${e}: `:""}${t} ${n?`${n} `:""}results in an unsatisfiable type`,K={Array,Date,Error,Function,Map,RegExp,Set,Object,String,Number,Boolean,WeakMap,WeakSet,Promise},G=(e,t)=>{if("object"!==o(e))return;const n=t??K;let r=Object.getPrototypeOf(e);for(;r?.constructor&&(!n[r.constructor.name]||!(e instanceof n[r.constructor.name]));)r=Object.getPrototypeOf(r);return r?.constructor?.name},H=e=>Array.isArray(e),_={Object:"an object",Array:"an array",Function:"a function",Date:"a Date",RegExp:"a RegExp",Error:"an Error",Map:"a Map",Set:"a Set",String:"a String object",Number:"a Number object",Boolean:"a Boolean object",Promise:"a Promise",WeakMap:"a WeakMap",WeakSet:"a WeakSet"},J=e=>{const t=Object(e).name;return t&&a(t,K)&&K[t]===e?t:void 0},Q=N(((e,t,n)=>e===t?U():e instanceof t?e:t instanceof e?t:n.addDisjoint("class",e,t))),X=(e,t)=>{if(Array.isArray(e)){if(Array.isArray(t)){const n=V(e,t);return n.length===e.length?n.length===t.length?U():e:n.length===t.length?t:n}return e.includes(t)?e:[...e,t]}return Array.isArray(t)?t.includes(e)?t:[...t,e]:e===t?U():[e,t]},V=(e,t)=>{const n=[...e];for(const r of t)e.includes(r)||n.push(r);return n},Y=N(((e,t)=>e===t?U():Math.abs(e*t/ee(e,t)))),ee=(e,t)=>{let n,r=e,s=t;for(;0!==s;)n=s,s=r%s,r=n;return r},te=e=>"?"===e[0],ne=e=>"!"===e[0],re={index:"[index]"},se=e=>te(e)||ne(e)?e[1]:e,oe=N(((e,t,n)=>{const r=ie(e,t,n);if("symbol"==typeof r)return r;const s=(e=>{if("object"==typeof e.length&&ne(e.length)&&"string"!=typeof e.length[1]&&et(e.length[1],"number"))return e.length[1].number.value})(r);if(void 0===s||!(re.index in r))return r;const{[re.index]:o,...i}=r,a=se(o);for(let e=0;e<s;e++){if(!i[e]){i[e]=a;continue}const t=se(i[e]);n.path.push(`${e}`);const r=He(t,a,n);if(n.path.pop(),q(r))return r;W(r)||r===t||(i[e]=r)}return i})),ie=Z(((e,t,n,r)=>{if(void 0===t)return void 0===n?U():n;if(void 0===n)return t;r.path.push(e);const s=r.lOptional,o=r.rOptional;(c=r).lOptional||(c.lOptional=te(t)),(l=r).rOptional||(l.rOptional=te(n));const i=He(se(t),se(n),r),a=r.lOptional&&r.rOptional;var c,l;return r.rOptional=o,r.lOptional=s,r.path.pop(),q(i)&&a?{}:i}),{onEmpty:"bubble"}),ae=e=>"string"==typeof e||Array.isArray(e)?e.length:"number"==typeof e?e:0;class ce{toString(){return O(this.value)}get domain(){return o(this.value)}get size(){return ae(this.value)}get units(){return"string"==typeof(e=this.value)?"characters":Array.isArray(e)?"items long":"";var e}get className(){return Object(this.value).constructor.name}constructor(e){!function(e,t,n){t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n}(this,"value",void 0),this.value=e}}const le={">":!0,">=":!0},ue={"<":!0,"<=":!0},he=e=>"comparator"in e,de=N(((e,t,n)=>{if(he(e))return he(t)?e.limit===t.limit?U():n.addDisjoint("range",e,t):pe(t,e.limit)?e:n.addDisjoint("range",e,t);if(he(t))return pe(e,t.limit)?t:n.addDisjoint("range",e,t);const r=ge("min",e.min,t.min),s=ge("max",e.max,t.max);return"l"===r?"r"===s?"l"===ge("min",e.min,t.max)?n.addDisjoint("range",e,t):{min:e.min,max:t.max}:e:"r"===r?"l"===s?"l"===ge("max",e.max,t.min)?n.addDisjoint("range",e,t):{min:t.min,max:e.max}:t:"l"===s?e:"r"===s?t:U()})),pe=(e,t)=>he(e)?t===e.limit:fe(e.min,t)&&me(e.max,t),fe=(e,t)=>!e||t>e.limit||t===e.limit&&!ve(e.comparator),me=(e,t)=>!e||t<e.limit||t===e.limit&&!ve(e.comparator),be={"<":(e,t)=>e<t,">":(e,t)=>e>t,"<=":(e,t)=>e<=t,">=":(e,t)=>e>=t,"==":(e,t)=>e===t},ge=(e,t,n)=>t?n?t.limit===n.limit?ve(t.comparator)?ve(n.comparator)?"=":"l":ve(n.comparator)?"r":"=":"min"===e?t.limit>n.limit?"l":"r":t.limit<n.limit?"l":"r":"l":n?"r":"=",ve=e=>1===e.length,ye={},we=e=>(ye[e]||(ye[e]=new RegExp(e)),ye[e]),$e=Z({divisor:Y,regex:N(X),props:oe,class:Q,range:de,narrow:N(X)},{onEmpty:"bubble"}),xe=(e,t)=>{const n=[];let r;for(r in e)je[r](n,e[r],t);return n.sort(((e,t)=>ke[e[0]]-ke[t[0]]))},je={regex:(e,t)=>{for(const n of d(t))e.push(["regex",n])},divisor:(e,t)=>{e.push(["divisor",t])},range:(e,t,n)=>{const r="string"===n.lastDomain?"characters":"object"===n.lastDomain?"items long":void 0;if(he(t))return e.push(["bound",r?{...t,units:r}:t]);t.min&&e.push(["bound",r?{...t.min,units:r}:t.min]),t.max&&e.push(["bound",r?{...t.max,units:r}:t.max])},class:(e,t)=>{e.push(["class",t])},props:(e,t,n)=>{const r=n.type.config?.keys??n.type.scope.config.keys;return"loose"===r?((e,t,n)=>{for(const r in t){const s=t[r];n.path.push(r),r===re.index?e.push(["indexProp",Ve(se(s),n)]):te(s)?e.push(["optionalProp",[r,Ve(s[1],n)]]):ne(s)?e.push(["prerequisiteProp",[r,Ve(s[1],n)]]):e.push(["requiredProp",[r,Ve(s,n)]]),n.path.pop()}})(e,t,n):((e,t,n,r)=>{const s={required:{},optional:{}};for(const e in n){const o=n[e];r.path.push(e),e===re.index?s.index=Ve(se(o),r):te(o)?s.optional[e]=Ve(o[1],r):ne(o)?t.push(["prerequisiteProp",[e,Ve(o[1],r)]]):s.required[e]=Ve(o,r),r.path.pop()}t.push([`${e}Props`,s])})(r,e,t,n)},narrow:(e,t)=>{for(const n of d(t))e.push(["narrow",n])},value:(e,t)=>{e.push(["value",t])}},ke={config:-1,domain:0,value:0,domains:0,branches:0,switch:0,alias:0,class:0,regex:1,divisor:1,bound:1,prerequisiteProp:2,distilledProps:3,strictProps:3,requiredProp:3,optionalProp:3,indexProp:3,narrow:4,morph:5},Oe=(e,t,n)=>!n.type.scope.type(["node",{[n.domain]:t}])(e).problems,Re=e=>void 0!==e?.lBranches,Be=e=>"rules"in e,Ae=(e,t)=>{if(Be(e)){const n=xe(e.rules,t);if(e.morph)if("function"==typeof e.morph)n.push(["morph",e.morph]);else for(const t of e.morph)n.push(["morph",t]);return n}return xe(e,t)},Pe=e=>e.rules??e,Te=(e,t,n)=>{const s=((e,t,n)=>"value"in e?"value"in t?e.value===t.value?U():n.addDisjoint("value",e.value,t.value):Oe(e.value,t,n)?e:n.addDisjoint("leftAssignability",e,t):"value"in t?Oe(t.value,e,n)?t:n.addDisjoint("rightAssignability",e,t):$e(e,t,n))(Pe(e),Pe(t),n);return"morph"in e?"morph"in t?e.morph===t.morph?W(s)||q(s)?s:{rules:s,morph:e.morph}:"&"===n.lastOperator?r(L(n.path,"Intersection","of morphs")):{}:q(s)?s:{rules:W(s)?e.rules:s,morph:e.morph}:"morph"in t?q(s)?s:{rules:W(s)?t.rules:s,morph:t.morph}:s},Ee=(e,t,n,s)=>{if(1===t.length)return Ae(e[t[0]],s);const o=Ie(t,n);if(!o)return[["branches",t.map((t=>{return Fe(e[t],s.type.scope)?r(("/"==(n=`${s.path}`)?"A":`At ${n}, a`)+" union including one or more morphs must be discriminatable"):Ae(e[t],s);var n}))]];const i={};for(const t in o.indexCases){const r=o.indexCases[t];i[t]=Ee(e,r,n,s),"default"!==t&&Ne(i[t],o.path,o,s)}return[["switch",{path:o.path,kind:o.kind,cases:i}]]},Ne=(e,t,n,r)=>{for(let o=0;o<e.length;o++){const[i,a]=e[o];if(t.length){if(("requiredProp"===i||"prerequisiteProp"===i||"optionalProp"===i)&&a[0]===t[0])return"string"==typeof a[1]?"domain"!==n.kind?Se(n):void e.splice(o,1):(Ne(a[1],t.slice(1),n,r),void(0===a[1].length&&e.splice(o,1)))}else if("domain"===n.kind){if("domain"===i||"domains"===i)return void e.splice(o,1);if("class"===i||"value"===i)return}else if(n.kind===i)return void e.splice(o,1);if("domains"===i)return 1===(s=a,Object.keys(s).length)&&a.object?void Ne(a.object,t,n,r):Se(n);if("switch"===i){for(const e in a.cases)Ne(a.cases[e],t,n,r);return}if("branches"===i){for(const e of a)Ne(e,t,n,r);return}}var s;return Se(n)},Se=e=>t(`Unexpectedly failed to discriminate ${e.kind} at path '${e.path}'`),Ce={domain:!0,class:!0,value:!0},De=e=>{const t=p.fromString(e);return[t,t.pop()]},Ie=(e,t)=>{let n;for(let r=0;r<e.length-1;r++){const s=e[r];for(let o=r+1;o<e.length;o++){const r=e[o],i=t.disjointsByPair[`${s}/${r}`];for(const r of i){const s=t.casesByDisjoint[r],o={},i=[...e];let a=0;for(const t in s){const n=s[t].filter((t=>{const n=e.indexOf(t);if(-1!==n)return delete i[n],!0}));0!==n.length&&(o[t]=n,a++)}const l=c(i);if(l.length&&(o.default=l.map((e=>parseInt(e)))),!n||a>n.score){const[t,s]=De(r);if(n={path:t,kind:s,indexCases:o,score:a},a===e.length)return n}}}}return n},ze=(e,t)=>{switch(e){case"value":return Me(t);case"domain":return t;case"class":return J(t);default:return}},Me=e=>{const t=o(e);return"object"===t||"symbol"===t?void 0:A(e)},qe={value:e=>Me(e)??"default",class:e=>G(e)??"default",domain:o},Fe=(e,t)=>"morph"in e||"props"in e&&Object.values(e.props).some((e=>Ue(se(e),t))),Ue=(e,t)=>"string"==typeof e?t.resolve(e).includesMorph:Object.values(t.resolveTypeNode(e)).some((e=>!0!==e&&(H(e)?e.some((e=>Fe(e,t))):Fe(e,t)))),We=e=>!0===e?{}:e,Ze=(e,n,r)=>{if(!0===e&&!0===n)return U();if(!H(e)&&!H(n)){const t=Te(We(e),We(n),r);return t===e?e:t===n?n:t}const i=d(We(e)),a=d(We(n)),c=((e,n,r)=>{const i={lBranches:e,rBranches:n,lExtendsR:[],rExtendsL:[],equalities:[],distinctIntersections:[]},a=n.map((e=>({condition:e,distinct:[]})));return e.forEach(((e,n)=>{let c=!1;const l=a.map(((a,l)=>{if(c||!a.distinct)return null;const u=a.condition,h=Te(e,u,r);return q(h)?null:h===e?(i.lExtendsR.push(n),c=!0,null):h===u?(i.rExtendsL.push(l),a.distinct=null,null):W(h)?(i.equalities.push([n,l]),c=!0,a.distinct=null,null):s(h,"object")?h:t(`Unexpected predicate intersection result of type '${o(h)}'`)}));if(!c)for(let e=0;e<a.length;e++)l[e]&&a[e].distinct?.push(l[e])})),i.distinctIntersections=a.flatMap((e=>e.distinct??[])),i})(i,a,r);return c.equalities.length===i.length&&c.equalities.length===a.length?U():c.lExtendsR.length+c.equalities.length===i.length?e:c.rExtendsL.length+c.equalities.length===a.length?n:c},Le=(e,t,n,r)=>{const s=new z(r,"|"),o=Ze(t,n,s);if(!Re(o))return W(o)||o===t?n:o===n?t:"boolean"===e||[We(t),We(n)];const i=[...o.lBranches.filter(((e,t)=>!o.lExtendsR.includes(t)&&!o.equalities.some((e=>e[0]===t)))),...o.rBranches.filter(((e,t)=>!o.rExtendsL.includes(t)&&!o.equalities.some((e=>e[1]===t))))];return 1===i.length?i[0]:i},Ke=(e,t)=>!0===e?[]:H(e)?((e,t)=>{const n=((e,t)=>{const n={disjointsByPair:{},casesByDisjoint:{}};for(let r=0;r<e.length-1;r++)for(let s=r+1;s<e.length;s++){const o=`${r}/${s}`,i=[];n.disjointsByPair[o]=i;const c=new z(t.type,"|");Te(e[r],e[s],c);for(const e in c.disjoints){if(e.includes(re.index))continue;const{l:t,r:o,kind:l,lOptional:u,rOptional:h}=c.disjoints[e];if(!a(l,Ce))continue;if(u||h)continue;const d=ze(l,t),p=ze(l,o);if(void 0===d||void 0===p)continue;const f="/"===e?l:`${e}/${l}`;if(i.push(f),!n.casesByDisjoint[f]){n.casesByDisjoint[f]={[d]:[r],[p]:[s]};continue}const m=n.casesByDisjoint[f],b=m[d];b?b.includes(r)||b.push(r):m[d]=[r];const g=m[p];g?g.includes(s)||g.push(s):m[p]=[s]}}return n})(e,t),r=e.map(((e,t)=>t));return Ee(e,r,n,t)})(e,t):Ae(e,t),Ge=e=>"config"in e,He=(e,t,n)=>{n.domain=void 0;const r=n.type.scope.resolveTypeNode(e),s=n.type.scope.resolveTypeNode(t),o=_e(r,s,n);return"object"!=typeof o||h(o)?o===r?e:o===s?t:o:h(n.disjoints)?M:n.addDisjoint("domain",c(r),c(s))},_e=Z(((e,n,r,s)=>void 0===n?void 0===r?t(S):void 0:void 0!==r?((e,t,n,r)=>{r.domain=e;const s=Ze(t,n,r);if(!Re(s))return s;const o=[...s.distinctIntersections,...s.equalities.map((e=>s.lBranches[e[0]])),...s.lExtendsR.map((e=>s.lBranches[e])),...s.rExtendsL.map((e=>s.rBranches[e]))];return 0===o.length&&r.addDisjoint("union",s.lBranches,s.rBranches),1===o.length?o[0]:o})(e,n,r,s):void 0),{onEmpty:"omit"}),Je=(e,t,n)=>{const s=new z(n,"&"),o=He(e,t,s);return q(o)?r((e=>{const t=c(e);if(1===t.length){const n=t[0];return`${"/"===n?"":`At ${n}: `}Intersection of ${C[e[n].kind](e[n])} results in an unsatisfiable type`}let n='\n        "Intersection results in unsatisfiable types at the following paths:\n';for(const t in e)n+=`  ${t}: ${C[e[t].kind](e[t])}\n`;return n})(s.disjoints)):W(o)?e:o},Qe=(e,n,r)=>{const s=r.scope.resolveTypeNode(e),o=r.scope.resolveTypeNode(n),i={},a=c({...s,...o});for(const e of a)i[e]=u(s,e)?u(o,e)?Le(e,s[e],o[e],r):s[e]:u(o,e)?o[e]:t(S);return i},Xe=e=>{const t={type:e,path:new p,lastDomain:"undefined"};return Ve(e.node,t)},Ve=(e,t)=>{if("string"==typeof e)return t.type.scope.resolve(e).flat;const n=Ge(e),r=Ye(n?e.node:e,t);return n?[["config",{config:(s=e.config,Object.entries(s)),node:r}]]:r;var s},Ye=(e,t)=>{const n=c(e);if(1===n.length){const r=n[0],s=e[r];if(!0===s)return r;t.lastDomain=r;const o=Ke(s,t);return(e=>e[0]&&("value"===e[0][0]||"class"===e[0][0]))(o)?o:[["domain",r],...o]}const r={};for(const s of n)t.lastDomain=s,r[s]=Ke(e[s],t);return[["domains",r]]},et=(e,t)=>{return tt(e,t)&&"object"==typeof(n=e[t])&&"value"in n;var n},tt=(e,t)=>{const n=c(e);return 1===n.length&&n[0]===t},nt=e=>({object:{class:Array,props:{[re.index]:e}}});function rt(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class st{shift(){return this.chars[this.i++]??""}get lookahead(){return this.chars[this.i]??""}shiftUntil(e){let t="";for(;this.lookahead;){if(e(this,t)){if(t[t.length-1]!==st.escapeToken)break;t=t.slice(0,-1)}t+=this.shift()}return t}shiftUntilNextTerminator(){return this.shiftUntil(st.lookaheadIsNotWhitespace),this.shiftUntil(st.lookaheadIsTerminator)}get unscanned(){return this.chars.slice(this.i,this.chars.length).join("")}lookaheadIs(e){return this.lookahead===e}lookaheadIsIn(e){return this.lookahead in e}constructor(e){rt(this,"chars",void 0),rt(this,"i",void 0),rt(this,"finalized",!1),this.chars=[...e],this.i=0}}function ot(e,t,n){if(!t.has(e))throw new TypeError("attempted to "+n+" private field on non-instance");return t.get(e)}function it(e,t){return function(e,t){return t.get?t.get.call(e):t.value}(e,ot(e,t,"get"))}function at(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}!function(e){e.lookaheadIsTerminator=e=>e.lookahead in n,e.lookaheadIsNotWhitespace=e=>e.lookahead!==r;var t=e.comparatorStartChars={"<":!0,">":!0,"=":!0},n=e.terminatingChars={...t,"|":!0,"&":!0,")":!0,"[":!0,"%":!0," ":!0},r=(e.comparators={"<":!0,">":!0,"<=":!0,">=":!0,"==":!0},e.oneCharComparators={"<":!0,">":!0},e.comparatorDescriptions={"<":"less than",">":"more than","<=":"at most",">=":"at least","==":"exactly"},e.invertedComparators={"<":">",">":"<","<=":">=",">=":"<=","==":"=="},e.branchTokens={"|":!0,"&":!0},e.escapeToken="\\",e.whiteSpaceToken=" ")}(st||(st={}));class ct extends TypeError{constructor(e){super(`${e}`),at(this,"cause",void 0),this.cause=e}}class lt{toString(){return this.message}get message(){return this.writers.addContext(this.reason,this.path)}get reason(){return this.writers.writeReason(this.mustBe,new ce(this.data))}get mustBe(){return"string"==typeof this.writers.mustBe?this.writers.mustBe:this.writers.mustBe(this.source)}constructor(e,t,n,r,s){at(this,"code",void 0),at(this,"path",void 0),at(this,"data",void 0),at(this,"source",void 0),at(this,"writers",void 0),at(this,"parts",void 0),this.code=e,this.path=t,this.data=n,this.source=r,this.writers=s,"multi"===this.code&&(this.parts=this.source)}}var ut=new WeakMap;const ht=class extends Array{mustBe(e,t){return this.add("custom",e,t)}add(e,t,n){const r=p.from(n?.path??it(this,ut).path),s=n&&"data"in n?n.data:it(this,ut).data,o=new lt(e,r,s,t,it(this,ut).getProblemConfig(e));return this.addProblem(o),o}addProblem(e){const t=`${e.path}`,n=this.byPath[t];if(n)if(n.parts)n.parts.push(e);else{const r=new lt("multi",n.path,n.data,[n,e],it(this,ut).getProblemConfig("multi")),s=this.indexOf(n);this[-1===s?this.length:s]=r,this.byPath[t]=r}else this.byPath[t]=e,this.push(e);this.count++}get summary(){return`${this}`}toString(){return this.join("\n")}throw(){throw new ct(this)}constructor(e){var t,n,r;super(),at(this,"byPath",{}),at(this,"count",0),r={writable:!0,value:void 0},function(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}(t=this,n=ut),n.set(t,r),function(e,t,n){(function(e,t,n){if(t.set)t.set.call(e,n);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=n}})(e,ot(e,t,"set"),n)}(this,ut,e)}},dt=e=>e.map((e=>i[e])),pt=e=>{if(0===e.length)return"never";if(1===e.length)return e[0];let t="";for(let n=0;n<e.length-1;n++)t+=e[n],n<e.length-2&&(t+=", ");return t+=` or ${e[e.length-1]}`,t},ft=(e,t)=>`must be ${e}${t&&` (was ${t})`}`,mt=(e,t)=>{return 0===t.length?(n=e)[0].toUpperCase()+n.slice(1):1===t.length&&g(t[0])?`Item at index ${t[0]} ${e}`:`${t} ${e}`;var n},bt={divisor:{mustBe:e=>1===e?"an integer":`a multiple of ${e}`},class:{mustBe:e=>{const t=J(e);return t?_[t]:`an instance of ${e.name}`},writeReason:(e,t)=>ft(e,t.className)},domain:{mustBe:e=>i[e],writeReason:(e,t)=>ft(e,t.domain)},missing:{mustBe:()=>"defined",writeReason:e=>ft(e,"")},extraneous:{mustBe:()=>"removed",writeReason:e=>ft(e,"")},bound:{mustBe:e=>`${st.comparatorDescriptions[e.comparator]} ${e.limit}${e.units?` ${e.units}`:""}`,writeReason:(e,t)=>ft(e,`${t.size}`)},regex:{mustBe:e=>`a string matching ${e}`},value:{mustBe:O},branches:{mustBe:e=>pt(e.map((e=>`${e.path} must be ${e.parts?pt(e.parts.map((e=>e.mustBe))):e.mustBe}`))),writeReason:(e,t)=>`${e} (was ${t})`,addContext:(e,t)=>t.length?`At ${t}, ${e}`:e},multi:{mustBe:e=>"• "+e.map((e=>e.mustBe)).join("\n• "),writeReason:(e,t)=>`${t} must be...\n${e}`,addContext:(e,t)=>t.length?`At ${t}, ${e}`:e},custom:{mustBe:e=>e},cases:{mustBe:e=>pt(e)}},gt=c(bt),vt=(()=>{const e={};let t;for(t of gt)e[t]={mustBe:bt[t].mustBe,writeReason:bt[t].writeReason??ft,addContext:bt[t].addContext??mt};return e})(),yt=e=>{if(!e)return vt;const t={};for(const n of gt)t[n]={mustBe:e[n]?.mustBe??bt[n].mustBe,writeReason:e[n]?.writeReason??bt[n].writeReason??e.writeReason??ft,addContext:e[n]?.addContext??bt[n].addContext??e.addContext??mt};return t};function wt(e,t,n){if(!t.has(e))throw new TypeError("attempted to "+n+" private field on non-instance");return t.get(e)}function $t(e,t){return function(e,t){return t.get?t.get.call(e):t.value}(e,wt(e,t,"get"))}function xt(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}const jt=["mustBe","writeReason","addContext"],kt=class{constructor(){xt(this,"data",void 0),xt(this,"problems",void 0)}};var Ot=new WeakMap;class Rt{getProblemConfig(e){const t={};for(const n of jt)t[n]=this.traversalConfig[n][0]??this.rootScope.config.codes[e][n];return t}traverseConfig(e,t){for(const t of e)this.traversalConfig[t[0]].unshift(t[1]);const n=Bt(t,this);for(const t of e)this.traversalConfig[t[0]].shift();return n}traverseKey(e,t){const n=this.data;this.data=this.data[e],this.path.push(e);const r=Bt(t,this);return this.path.pop(),n[e]!==this.data&&(n[e]=this.data),this.data=n,r}traverseResolution(e){const t=this.type.scope.resolve(e),n=t.qualifiedName,r=this.data,o=s(r,"object");if(o){const e=$t(this,Ot)[n];if(e){if(e.includes(r))return!0;e.push(r)}else $t(this,Ot)[n]=[r]}const i=this.type;this.type=t;const a=Bt(t.flat,this);return this.type=i,o&&$t(this,Ot)[n].pop(),a}traverseBranches(e){const t=this.failFast;this.failFast=!0;const n=this.problems,r=new ht(this);this.problems=r;const s=this.path,o=this.entriesToPrune;let i=!1;for(const t of e)if(this.path=new p,this.entriesToPrune=[],At(t,this)){i=!0,o.push(...this.entriesToPrune);break}return this.path=s,this.entriesToPrune=o,this.problems=n,this.failFast=t,i||!this.problems.add("branches",r)}constructor(e,t){var n,r,s;xt(this,"data",void 0),xt(this,"type",void 0),xt(this,"path",void 0),xt(this,"problems",void 0),xt(this,"entriesToPrune",void 0),xt(this,"failFast",void 0),xt(this,"traversalConfig",void 0),xt(this,"rootScope",void 0),s={writable:!0,value:void 0},function(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}(n=this,r=Ot),r.set(n,s),this.data=e,this.type=t,this.path=new p,this.problems=new ht(this),this.entriesToPrune=[],this.failFast=!1,this.traversalConfig={mustBe:[],writeReason:[],addContext:[],keys:[]},function(e,t,n){(function(e,t,n){if(t.set)t.set.call(e,n);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=n}})(e,wt(e,t,"set"),n)}(this,Ot,{}),this.rootScope=t.scope}}const Bt=(e,t)=>"string"==typeof e?o(t.data)===e||!t.problems.add("domain",e):At(e,t),At=(e,t)=>{let n=!0;for(let r=0;r<e.length;r++){const[s,o]=e[r],i=Et[s](o,t);if(n&&(n=i),!n){if(t.failFast)return!1;if(r<e.length-1&&ke[s]<ke[e[r+1][0]])return!1}}return n},Pt=(e,t)=>e[0]in t.data?t.traverseKey(e[0],e[1]):(t.problems.add("missing",void 0,{path:t.path.concat(e[0]),data:void 0}),!1),Tt=e=>(t,n)=>{let r=!0;const s={...t.required};for(const o in n.data)if(t.required[o]?(r=n.traverseKey(o,t.required[o])&&r,delete s[o]):t.optional[o]?r=n.traverseKey(o,t.optional[o])&&r:t.index&&b.test(o)?r=n.traverseKey(o,t.index)&&r:"distilledProps"===e?n.failFast?n.entriesToPrune.push([n.data,o]):delete n.data[o]:(r=!1,n.problems.add("extraneous",n.data[o],{path:n.path.concat(o)})),!r&&n.failFast)return!1;const o=Object.keys(s);if(o.length){for(const e of o)n.problems.add("missing",void 0,{path:n.path.concat(e)});return!1}return r},Et={regex:(e,t)=>we(e).test(t.data)||!t.problems.add("regex",`/${e}/`),divisor:(e,t)=>t.data%e==0||!t.problems.add("divisor",e),domains:(e,t)=>{const n=e[o(t.data)];return n?At(n,t):!t.problems.add("cases",dt(c(e)))},domain:(e,t)=>o(t.data)===e||!t.problems.add("domain",e),bound:(e,t)=>be[e.comparator](ae(t.data),e.limit)||!t.problems.add("bound",e),optionalProp:(e,t)=>!(e[0]in t.data)||t.traverseKey(e[0],e[1]),requiredProp:Pt,prerequisiteProp:Pt,indexProp:(e,t)=>{if(!Array.isArray(t.data))return t.problems.add("class",Array),!1;let n=!0;for(let r=0;r<t.data.length;r++)if(n=t.traverseKey(`${r}`,e)&&n,!n&&t.failFast)return!1;return n},branches:(e,t)=>t.traverseBranches(e),switch:(e,n)=>{const r=((e,t)=>{let n=e;for(const e of t){if("object"!=typeof n||null===n)return;n=n[e]}return n})(n.data,e.path),s=(o=e.kind,i=r,qe[o](i));var o,i;if(u(e.cases,s))return At(e.cases[s],n);const a=c(e.cases),l=n.path.concat(e.path),h="value"===e.kind?a:"domain"===e.kind?dt(a):"class"===e.kind?a.map((e=>_[e])):t(`Unexpectedly encountered rule kind '${e.kind}' during traversal`);return n.problems.add("cases",h,{path:l,data:r}),!1},alias:(e,t)=>t.traverseResolution(e),class:(e,t)=>"string"==typeof e?G(t.data)===e||!t.problems.add("class",e):t.data instanceof e||!t.problems.add("class",e),narrow:(e,t)=>{const n=t.problems.count,r=e(t.data,t.problems);return r||t.problems.count!==n||t.problems.mustBe(e.name?`valid according to ${e.name}`:"valid"),r},config:({config:e,node:t},n)=>n.traverseConfig(e,t),value:(e,t)=>t.data===e||!t.problems.add("value",e),morph:(e,t)=>{const n=e(t.data,t.problems);if(t.problems.length)return!1;if(n instanceof lt)return t.problems.addProblem(n),!1;if(n instanceof kt){if(n.problems){for(const e of n.problems)t.problems.addProblem(e);return!1}return t.data=n.data,!0}return t.data=n,!0},distilledProps:Tt("distilledProps"),strictProps:Tt("strictProps")},Nt=new Proxy((()=>Nt),{get:()=>Nt}),St=(e,t,n,r)=>{const s={node:e,flat:[["alias",e]],allows:e=>!o(e).problems,assert:e=>{const t=o(e);return t.problems?t.problems.throw():t.data},infer:Nt,inferIn:Nt,qualifiedName:Dt(e)?r.getAnonymousQualifiedName(e):`${r.name}.${e}`,definition:t,scope:r,includesMorph:!1,config:n},o={[e]:e=>((e,t)=>{const n=new Rt(t,e);Bt(e.flat,n);const r=new kt(n);if(n.problems.count)r.problems=n.problems;else{for(const[e,t]of n.entriesToPrune)delete e[t];r.data=n.data}return r})(o,e)}[e];return Object.assign(o,s)},Ct=e=>e?.infer===Nt,Dt=e=>"λ"===e[0],It=e=>{const t=x(e);if(void 0!==t)return{number:{value:t}};const n=(e=>{if("n"!==e[e.length-1])return;const t=e.slice(0,-1);let n;try{n=BigInt(t)}catch{return}return b.test(t)?n:y.test(t)?r($(e,"bigint")):void 0})(e);return void 0!==n?{bigint:{value:n}}:void 0},zt=e=>`'${e}' is unresolvable`,Mt=e=>{const t=e.previousOperator();return t?qt(t,e.scanner.unscanned):Ft(e.scanner.unscanned)},qt=(e,t)=>`Token '${e}' requires a right operand${t?` before '${t}'`:""}`,Ft=e=>"Expected an expression"+(e?` before '${e}'`:""),Ut=e=>Object.isFrozen(e)?e:Array.isArray(e)?Object.freeze(e.map(Ut)):Wt(e),Wt=e=>{for(const t in e)Ut(e[t]);return e},Zt=Ut({regex:v.source}),Lt=Ut({range:{min:{comparator:">=",limit:0}},divisor:1}),Kt={bigint:l(0n),boolean:l(!1),null:[],number:l(0),object:[],string:l(""),symbol:l(Symbol()),undefined:[]},Gt=e=>{if(!e.length)return[];let t=e[0];for(let n=1;n<e.length;n++)t=t.filter((t=>e[n].includes(t)));return t},Ht=e=>{const t=[];if("props"in e)for(const n of Object.keys(e.props))n===re.index?t.push(v):t.includes(n)||(t.push(n),v.test(n)&&t.push(j(n,`Unexpectedly failed to parse an integer from key '${n}'`)));if("class"in e){const n="string"==typeof e.class?K[e.class]:e.class;for(const e of l(n.prototype))t.includes(e)||t.push(e)}return t},_t=(e,t)=>Be(e)?{...e,morph:e.morph?Array.isArray(e.morph)?[...e.morph,t]:[e.morph,t]:t}:{rules:e,morph:t},Jt=e=>`Expected a Function or Record<Domain, Function> operand (${O(e)} was invalid)`,Qt=(e,t)=>{if(void 0===e[2])return r(qt(e[1],""));const n=wn(e[0],t),s=wn(e[2],t);return"&"===e[1]?Je(n,s,t.type):Qe(n,s,t.type)},Xt={"|":Qt,"&":Qt,"[]":(e,t)=>nt(wn(e[0],t)),"=>":(e,t)=>{const n=wn(e[0],t),o=t.type.scope.resolveNode(n),i=Ge(o),a=i?o.node:o,l=Je(n,((e,t,n,o)=>{const i=c(t);if(!s(e,"object"))return r(Jt(e));const a={};if("function"==typeof e){const t={[o]:e};for(const e of i)a[e]=t}else for(const t of i){if(void 0===e[t])continue;const n={[o]:e[t]};if("function"!=typeof n[o])return r(Jt(n));a[t]=n}return a})(e[2],a,0,"narrow"),t.type);return i?{config:o.config,node:l}:l},"|>":(e,n)=>{if("function"!=typeof e[2])return r(`Morph expression requires a function following '|>' (was ${typeof e[2]})`);const s=wn(e[0],n),o=n.type.scope.resolveTypeNode(s),i=e[2];let a;n.type.includesMorph=!0;const c={};for(a in o){const e=o[a];!0===e?c[a]={rules:{},morph:i}:"object"==typeof e?c[a]=H(e)?e.map((e=>_t(e,i))):_t(e,i):t(`Unexpected predicate value for domain '${a}': ${O(e)}`)}return c},":":(e,t)=>({node:t.type.scope.resolveTypeNode(wn(e[0],t)),config:e[2]})},Vt={keyof:(e,n)=>{const r=n.type.scope.resolveNode(wn(e[1],n)),s=c(r).map((e=>((e,t)=>"object"!==e||!0===t?Kt[e]:Gt(d(t).map((e=>Ht(e)))))(e,r[e]))),o=Gt(s);if(!o.length)return L(n.path,"keyof");const i={};for(const e of o){const n=typeof e;if("string"===n||"number"===n||"symbol"===n){var a,l;(a=i)[l=n]??(a[l]=[]),i[n].push({value:e})}else{if(e!==v)return t(`Unexpected keyof key '${O(e)}'`);var u,h;(u=i).string??(u.string=[]),i.string.push(Zt),(h=i).number??(h.number=[]),i.number.push(Lt)}}return Object.fromEntries(Object.entries(i).map((([e,t])=>[e,1===t.length?t[0]:t])))},instanceof:e=>"function"!=typeof e[1]?r(`Expected a constructor following 'instanceof' operator (was ${typeof e[1]}).`):{object:{class:e[1]}},"===":e=>({[o(e[1])]:{value:e[1]}}),node:e=>e[1]},Yt=e=>`Left-bounded expressions must specify their limits using < or <= (was ${e})`;function en(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class tn{error(e){return r(e)}hasRoot(){return void 0!==this.root}resolveRoot(){return this.assertHasRoot(),this.ctx.type.scope.resolveTypeNode(this.root)}rootToString(){return this.assertHasRoot(),O(this.root)}ejectRootIfLimit(){this.assertHasRoot();const e="string"==typeof this.root?this.ctx.type.scope.resolveNode(this.root):this.root;if(et(e,"number")){const t=e.number.value;return this.root=void 0,t}}ejectRangeIfOpen(){if(this.branches.range){const e=this.branches.range;return delete this.branches.range,e}}assertHasRoot(){if(void 0===this.root)return t("Unexpected interaction with unset root")}assertUnsetRoot(){if(void 0!==this.root)return t("Unexpected attempt to overwrite root")}setRoot(e){this.assertUnsetRoot(),this.root=e}rootToArray(){this.root=nt(this.ejectRoot())}intersect(e){this.root=Je(this.ejectRoot(),e,this.ctx.type)}ejectRoot(){this.assertHasRoot();const e=this.root;return this.root=void 0,e}ejectFinalizedRoot(){this.assertHasRoot();const e=this.root;return this.root=nn,e}finalize(){if(this.groups.length)return this.error("Missing )");this.finalizeBranches(),this.scanner.finalized=!0}reduceLeftBound(e,t){const n=st.invertedComparators[t];return a(n,le)?this.branches.range?this.error(((e,t,n,r)=>`An expression may have at most one left bound (parsed ${e}${st.invertedComparators[t]}, ${n}${st.invertedComparators[r]})`)(`${this.branches.range.limit}`,this.branches.range.comparator,`${e}`,n)):void(this.branches.range={limit:e,comparator:n}):this.error(Yt(t))}finalizeBranches(){this.assertRangeUnset(),this.branches.union?(this.pushRootToBranch("|"),this.setRoot(this.branches.union)):this.branches.intersection&&this.setRoot(Je(this.branches.intersection,this.ejectRoot(),this.ctx.type))}finalizeGroup(){this.finalizeBranches();const e=this.groups.pop();if(!e)return this.error("Unmatched )"+(""===(t=this.scanner.unscanned)?"":` before ${t}`));var t;this.branches=e}pushRootToBranch(e){this.assertRangeUnset(),this.branches.intersection=this.branches.intersection?Je(this.branches.intersection,this.ejectRoot(),this.ctx.type):this.ejectRoot(),"|"===e&&(this.branches.union=this.branches.union?Qe(this.branches.union,this.branches.intersection,this.ctx.type):this.branches.intersection,delete this.branches.intersection)}assertRangeUnset(){if(this.branches.range)return this.error((e=`${this.branches.range.limit}`,`Left bounds are only valid when paired with right bounds (try ...${this.branches.range.comparator}${e})`));var e}reduceGroupOpen(){this.groups.push(this.branches),this.branches={}}previousOperator(){return this.branches.range?.comparator??this.branches.intersection?"&":this.branches.union?"|":void 0}shiftedByOne(){return this.scanner.shift(),this}constructor(e,t){en(this,"ctx",void 0),en(this,"scanner",void 0),en(this,"root",void 0),en(this,"branches",void 0),en(this,"groups",void 0),this.ctx=t,this.branches={},this.groups=[],this.scanner=new st(e)}}const nn=new Proxy({},{get:()=>t("Unexpected attempt to access ejected attributes")}),rn={"'":1,'"':1,"/":1},sn={"'":e=>"'"===e.lookahead,'"':e=>'"'===e.lookahead,"/":e=>"/"===e.lookahead},on={'"':"double-quote","'":"single-quote","/":"forward slash"},an=e=>""===e.scanner.lookahead?e.error(Mt(e)):"("===e.scanner.lookahead?e.shiftedByOne().reduceGroupOpen():e.scanner.lookaheadIsIn(rn)?((e,t)=>{const n=e.scanner.shiftUntil(sn[t]);if(""===e.scanner.lookahead)return e.error(((e,t)=>`${t}${e} requires a closing ${on[t]}`)(n,t));"/"===e.scanner.shift()?(we(n),e.setRoot({string:{regex:n}})):e.setRoot({string:{value:n}})})(e,e.scanner.shift()):" "===e.scanner.lookahead?an(e.shiftedByOne()):(e=>{const t=e.scanner.shiftUntilNextTerminator();e.setRoot(((e,t)=>e.ctx.type.scope.addParsedReferenceIfResolvable(t,e.ctx)?t:It(t)??e.error(""===t?Mt(e):zt(t)))(e,t))})(e),cn="= is not a valid comparator. Use == to check for equality",ln=(e,t)=>{const n=t.resolveRoot(),r=c(n),s={},o={range:e};return r.every((e=>{switch(e){case"string":return s.string=o,!0;case"number":return s.number=o,!0;case"object":return s.object=o,!0!==n.object&&d(n.object).every((e=>"class"in e&&e.class===Array));default:return!1}}))||t.error(`Bounded expression ${t.rootToString()} must be a number, string or array`),s},un=(e,t)=>e.comparator===t,hn=(e,t)=>e.comparator in t,dn=(e,t)=>`Comparator ${e} must be followed by a number literal (was '${t}')`,pn=e=>`${D(e)} is empty`,fn=e=>`% operator must be followed by a non-zero integer literal (was ${e})`,mn=e=>{const n=e.scanner.shift();return""===n?e.finalize():"["===n?"]"===e.scanner.shift()?e.rootToArray():e.error(gn):a(n,st.branchTokens)?e.pushRootToBranch(n):")"===n?e.finalizeGroup():a(n,st.comparatorStartChars)?((e,n)=>{const r=((e,t)=>e.scanner.lookaheadIs("=")?`${t}${e.scanner.shift()}`:a(t,st.oneCharComparators)?t:e.error(cn))(e,n),s=e.ejectRootIfLimit();return void 0===s?((e,n)=>{const r=e.scanner.shiftUntilNextTerminator(),s=x(r,dn(n,r+e.scanner.unscanned)),o=e.ejectRangeIfOpen(),i={comparator:n,limit:s},a=o?hn(i,ue)?"l"===ge("min",o,i)?e.error(pn({min:o,max:i})):{min:o,max:i}:e.error(Yt(n)):un(i,"==")?i:hn(i,le)?{min:i}:hn(i,ue)?{max:i}:t(`Unexpected comparator '${i.comparator}'`);e.intersect(ln(a,e))})(e,r):e.reduceLeftBound(s,r)})(e,n):"%"===n?(e=>{const t=e.scanner.shiftUntilNextTerminator(),n=j(t,fn(t));0===n&&e.error(fn(0));const r=c(e.resolveRoot());1===r.length&&"number"===r[0]?e.intersect({number:{divisor:n}}):e.error(`Divisibility operand ${e.rootToString()} must be a number`)})(e):" "===n?mn(e):t(bn(n))},bn=e=>`Unexpected character '${e}'`,gn="Missing expected ']'",vn=e=>{for(;!e.scanner.finalized;)yn(e);return e.ejectFinalizedRoot()},yn=e=>e.hasRoot()?mn(e):an(e),wn=(e,t)=>{const n=o(e);if("string"===n)return((e,t)=>t.type.scope.parseCache.get(e)??t.type.scope.parseCache.set(e,((e,t)=>{if(t.type.scope.addParsedReferenceIfResolvable(e,t))return e;if(e.endsWith("[]")){const n=e.slice(0,-2);if(t.type.scope.addParsedReferenceIfResolvable(e,t))return nt(n)}})(e,t)??((e,t)=>{const n=new tn(e,t);return an(n),vn(n)})(e,t)))(e,t);if("object"!==n)return r(xn(n));const s=G(e);switch(s){case"Object":return((e,t)=>{const n={};for(const r in e){let s=r,o=!1;"?"===r[r.length-1]&&(r[r.length-2]===st.escapeToken?s=`${r.slice(0,-2)}?`:(s=r.slice(0,-1),o=!0)),t.path.push(s);const i=wn(e[r],t);t.path.pop(),n[s]=o?["?",i]:i}return{object:{props:n}}})(e,t);case"Array":return((e,t)=>{if((e=>void 0!==Xt[e[1]])(e))return Xt[e[1]](e,t);if((e=>void 0!==Vt[e[0]])(e))return Vt[e[0]](e,t);const n={length:["!",{number:{value:e.length}}]};for(let r=0;r<e.length;r++)t.path.push(`${r}`),n[r]=wn(e[r],t),t.path.pop();return{object:{class:Array,props:n}}})(e,t);case"RegExp":return{string:{regex:e.source}};case"Function":if(Ct(e))return t.type.scope.addAnonymousTypeReference(e,t);if($n(e)){const n=e();if(Ct(n))return t.type.scope.addAnonymousTypeReference(n,t)}return r(xn("Function"));default:return r(xn(s??O(e)))}},$n=(Symbol("as"),e=>"function"==typeof e&&0===e.length),xn=e=>`Type definitions must be strings or objects (was ${e})`;class jn{get root(){return this.cache}has(e){return e in this.cache}get(e){return this.cache[e]}set(e,t){return this.cache[e]=t,t}constructor(){var e,t;t={},(e="cache")in this?Object.defineProperty(this,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):this[e]=t}}class kn extends jn{set(e,t){return this.cache[e]=Ut(t),t}}function On(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}function Rn(e,t,n){if(!t.has(e))throw new TypeError("attempted to "+n+" private field on non-instance");return t.get(e)}function Bn(e,t){return function(e,t){return t.get?t.get.call(e):t.value}(e,Rn(e,t,"get"))}function An(e,t,n){On(e,t),t.set(e,n)}function Pn(e,t,n){return function(e,t,n){if(t.set)t.set.call(e,n);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=n}}(e,Rn(e,t,"set"),n),n}function Tn(e,t,n){if(!t.has(e))throw new TypeError("attempted to get private field on non-instance");return n}function En(e,t){On(e,t),t.add(e)}function Nn(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}let Sn=0;const Cn={},Dn={};var In=new WeakMap,zn=new WeakMap,Mn=new WeakSet,qn=new WeakSet,Fn=new WeakSet,Un=new WeakSet;class Wn{getAnonymousQualifiedName(e){let t=0,n=e;for(;this.isResolvable(n);)n=`${e}${t++}`;return`${this.name}.${n}`}addAnonymousTypeReference(e,t){var n;return(n=t.type).includesMorph||(n.includesMorph=e.includesMorph),e.node}get infer(){return Nt}compile(){if(!Dn[this.name]){for(const e in this.aliases)this.resolve(e);Dn[this.name]=Bn(this,zn).root}return Bn(this,zn).root}addParsedReferenceIfResolvable(e,t){var n;const r=Tn(this,Un,Gn).call(this,e,"undefined",[e]);return!!r&&((n=t.type).includesMorph||(n.includesMorph=r.includesMorph),!0)}resolve(e){return Tn(this,Un,Gn).call(this,e,"throw",[e])}resolveNode(e){return"string"==typeof e?this.resolveNode(this.resolve(e).node):e}resolveTypeNode(e){const t=this.resolveNode(e);return Ge(t)?t.node:t}isResolvable(e){return Bn(this,In).has(e)||this.aliases[e]}constructor(e,t={}){En(this,Mn),En(this,qn),En(this,Fn),En(this,Un),Nn(this,"aliases",void 0),Nn(this,"name",void 0),Nn(this,"config",void 0),Nn(this,"parseCache",void 0),An(this,In,{writable:!0,value:void 0}),An(this,zn,{writable:!0,value:void 0}),Nn(this,"expressions",void 0),Nn(this,"intersection",void 0),Nn(this,"union",void 0),Nn(this,"arrayOf",void 0),Nn(this,"keyOf",void 0),Nn(this,"valueOf",void 0),Nn(this,"instanceOf",void 0),Nn(this,"narrow",void 0),Nn(this,"morph",void 0),Nn(this,"type",void 0),this.aliases=e,this.parseCache=new kn,Pn(this,In,new jn),Pn(this,zn,new jn),this.expressions={intersection:(e,t,n)=>this.type([e,"&",t],n),union:(e,t,n)=>this.type([e,"|",t],n),arrayOf:(e,t)=>this.type([e,"[]"],t),keyOf:(e,t)=>this.type(["keyof",e],t),node:(e,t)=>this.type(["node",e],t),instanceOf:(e,t)=>this.type(["instanceof",e],t),valueOf:(e,t)=>this.type(["===",e],t),narrow:(e,t,n)=>this.type([e,"=>",t],n),morph:(e,t,n)=>this.type([e,"|>",t],n)},this.intersection=this.expressions.intersection,this.union=this.expressions.union,this.arrayOf=this.expressions.arrayOf,this.keyOf=this.expressions.keyOf,this.valueOf=this.expressions.valueOf,this.instanceOf=this.expressions.instanceOf,this.narrow=this.expressions.narrow,this.morph=this.expressions.morph,this.type=Object.assign(((e,t={})=>{const n=St("λtype",e,t,this),r=Tn(this,Fn,Kn).call(this,n),s=wn(e,r);return n.node=Ut(h(t)?{config:t,node:this.resolveTypeNode(s)}:s),n.flat=Ut(Xe(n)),n}),{from:this.expressions.node}),this.name=Tn(this,Mn,Zn).call(this,t),!1!==t.standard&&Tn(this,qn,Ln).call(this,[Dn.standard],"imports"),t.imports&&Tn(this,qn,Ln).call(this,t.imports,"imports"),t.includes&&Tn(this,qn,Ln).call(this,t.includes,"includes"),this.config=(e=>({codes:yt(e.codes),keys:e.keys??"loose"}))(t)}}function Zn(e){const t=e.name?Cn[e.name]?r(`A scope named '${e.name}' already exists`):e.name:"scope"+ ++Sn;return Cn[t]=this,t}function Ln(e,t){for(const n of e)for(const e in n)(Bn(this,In).has(e)||e in this.aliases)&&r(Xn(e)),Bn(this,In).set(e,n[e]),"includes"===t&&Bn(this,zn).set(e,n[e])}function Kn(e){return{type:e,path:new p}}function Gn(e,n,s){const o=Bn(this,In).get(e);if(o)return o;const i=this.aliases[e];if(!i)return"throw"===n?t(`Unexpectedly failed to resolve alias '${e}'`):void 0;const a=St(e,i,{},this),c=Tn(this,Fn,Kn).call(this,a);Bn(this,In).set(e,a),Bn(this,zn).set(e,a);let l=wn(i,c);if("string"==typeof l){if(s.includes(l))return r(Qn(e,s));s.push(l),l=Tn(this,Un,Gn).call(this,l,"throw",s).node}return a.node=Ut(l),a.flat=Ut(Xe(a)),a}const Hn=(e,t={})=>new Wn(e,t),_n=Hn({},{name:"root",standard:!1}),Jn=_n.type,Qn=(e,t)=>`Alias '${e}' has a shallow resolution cycle: ${[...t,e].join("=>")}`,Xn=e=>`Alias '${e}' is already defined`,Vn=Hn({Function:["node",{object:{class:Function}}],Date:["node",{object:{class:Date}}],Error:["node",{object:{class:Error}}],Map:["node",{object:{class:Map}}],RegExp:["node",{object:{class:RegExp}}],Set:["node",{object:{class:Set}}],WeakMap:["node",{object:{class:WeakMap}}],WeakSet:["node",{object:{class:WeakSet}}],Promise:["node",{object:{class:Promise}}]},{name:"jsObjects",standard:!1}),Yn=Vn.compile(),er={bigint:!0,boolean:!0,null:!0,number:!0,object:!0,string:!0,symbol:!0,undefined:!0},tr=Hn({any:["node",er],bigint:["node",{bigint:!0}],boolean:["node",{boolean:!0}],false:["node",{boolean:{value:!1}}],never:["node",{}],null:["node",{null:!0}],number:["node",{number:!0}],object:["node",{object:!0}],string:["node",{string:!0}],symbol:["node",{symbol:!0}],true:["node",{boolean:{value:!0}}],unknown:["node",er],void:["node",{undefined:!0}],undefined:["node",{undefined:!0}]},{name:"ts",standard:!1}),nr=tr.compile(),rr=Jn([/^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/,"=>",(e,t)=>(e=>{const t=e.replace(/[- ]+/g,"");let n,r,s,o=0;for(let e=t.length-1;e>=0;e--)n=t.substring(e,e+1),r=parseInt(n,10),s?(r*=2,o+=r>=10?r%10+1:r):o+=r,s=!s;return!(o%10!=0||!t)})(e)||!t.mustBe("a valid credit card number")],{mustBe:"a valid credit card number"}),sr=/^[./-]$/,or=/^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/,ir=e=>`a ${e}-formatted date`,ar=Jn([nr.string,"|>",(e,t)=>{const n=((e,t)=>{if(!t?.format){const t=new Date(e);return(e=>!isNaN(e))(t)?t:"a valid date"}if("iso8601"===t.format)return or.test(e)?new Date(e):ir("iso8601");const n=e.split(sr),r=e[n[0].length],s=r?t.format.split(r):[t.format];if(n.length!==s.length)return ir(t.format);const o={};for(let e=0;e<s.length;e++){if(n[e].length!==s[e].length&&(1!==s[e].length||2!==n[e].length))return ir(t.format);o[s[e][0]]=n[e]}const i=new Date(`${o.m}/${o.d}/${o.y}`);return`${i.getDate()}`===o.d?i:ir(t.format)})(e);return"string"==typeof n?t.mustBe(n):n}]),cr=Jn([f,"|>",e=>parseFloat(e)],{mustBe:"a well-formed numeric string"}),lr=Jn([nr.string,"|>",(e,t)=>{if(!g(e))return t.mustBe("a well-formed integer string");const n=parseInt(e);return Number.isSafeInteger(n)?n:t.mustBe("an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER")}]),ur=Hn({alpha:[/^[A-Za-z]*$/,":",{mustBe:"only letters"}],alphanumeric:[/^[A-Za-z\d]*$/,":",{mustBe:"only letters and digits"}],lowercase:[/^[a-z]*$/,":",{mustBe:"only lowercase letters"}],uppercase:[/^[A-Z]*$/,":",{mustBe:"only uppercase letters"}],creditCard:rr,email:Jn(/^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/,{mustBe:"a valid email"}),uuid:Jn(/^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/,{mustBe:"a valid UUID"}),parsedNumber:cr,parsedInteger:lr,parsedDate:ar,semver:Jn(/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/,{mustBe:"a valid semantic version (see https://semver.org/)"}),json:Jn([nr.string,"|>",e=>JSON.parse(e)],{mustBe:"a JSON-parsable string"}),integer:["node",{number:{divisor:1}}]},{name:"validation",standard:!1}),hr=Hn({},{name:"standard",includes:[nr,Yn,ur.compile()],standard:!1}),dr=(hr.compile(),{root:_n,tsKeywords:tr,jsObjects:Vn,validation:ur,ark:hr}),pr=hr.type;dr.ark.intersection,dr.ark.union,dr.ark.arrayOf,dr.ark.keyOf,dr.ark.instanceOf,dr.ark.valueOf,dr.ark.narrow,dr.ark.morph,pr({name:"string",age:"number"})})();